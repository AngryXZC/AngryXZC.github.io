<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"angryxzc.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Spring的核心容器(IoC)">
<meta property="og:type" content="article">
<meta property="og:title" content="精通Spring4.x企业应用开发实战-Chapter04">
<meta property="og:url" content="http://angryxzc.github.io/2024/05/14/%E7%B2%BE%E9%80%9ASpring4-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-Chapter04/index.html">
<meta property="og:site_name" content="星之辰的博客">
<meta property="og:description" content="Spring的核心容器(IoC)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://angryxzc.github.io/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%B1%BB%E5%AE%9E%E4%BE%8B-%E7%B1%BB%E6%8F%8F%E8%BF%B0-%E8%A3%85%E8%BD%BD%E5%99%A8.png">
<meta property="og:image" content="http://angryxzc.github.io/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/Spring%E5%92%8Cweb%E5%BA%94%E2%BD%A4%E7%9A%84%E4%B8%8A%E4%B8%8B%E2%BD%82%E8%9E%8D%E5%90%88.png">
<meta property="og:image" content="http://angryxzc.github.io/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/Application%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="article:published_time" content="2024-05-14T01:07:08.000Z">
<meta property="article:modified_time" content="2024-06-12T02:23:30.819Z">
<meta property="article:author" content="星之辰">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="精通Spring4.x企业应用开发实战">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://angryxzc.github.io/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%B1%BB%E5%AE%9E%E4%BE%8B-%E7%B1%BB%E6%8F%8F%E8%BF%B0-%E8%A3%85%E8%BD%BD%E5%99%A8.png">


<link rel="canonical" href="http://angryxzc.github.io/2024/05/14/%E7%B2%BE%E9%80%9ASpring4-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-Chapter04/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://angryxzc.github.io/2024/05/14/%E7%B2%BE%E9%80%9ASpring4-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-Chapter04/","path":"2024/05/14/精通Spring4-x企业应用开发实战-Chapter04/","title":"精通Spring4.x企业应用开发实战-Chapter04"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>精通Spring4.x企业应用开发实战-Chapter04 | 星之辰的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星之辰的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What I cannot create, I do not understand-Feynman Diagram</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%AE%B9%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">IoC容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">IoC概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E7%90%86%E8%A7%A3IoC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">通过实例理解IoC概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">2.1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%9A%84%E6%83%B3%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">直接的想法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%901"><span class="nav-number">2.1.3.</span> <span class="nav-text">问题分析1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%A7%92%E8%89%B2%E7%BC%96%E6%8E%92%E5%89%A7%E6%9C%AC"><span class="nav-number">2.1.4.</span> <span class="nav-text">通过角色编排剧本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%902"><span class="nav-number">2.1.5.</span> <span class="nav-text">问题分析2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IoC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">IoC的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%AE%8C%E6%88%90%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%B3%A8%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">通过容器完成依赖关系注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">3.</span> <span class="nav-text">相关Java基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.1.</span> <span class="nav-text">简单实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8ClassLoader"><span class="nav-number">3.2.</span> <span class="nav-text">类装载器ClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">类装载器的工作机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader-%E7%9A%84%E9%87%8D%E8%A6%81%E2%BD%85%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">ClassLoader 的重要⽅法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">Java 反射机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%88%A9%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">资源访问利器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">资源抽象接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.2.</span> <span class="nav-text">资源加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory%E5%92%8CApplicationContext"><span class="nav-number">5.</span> <span class="nav-text">BeanFactory和ApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">BeanFactory介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory-%E7%9A%84%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.1.</span> <span class="nav-text">BeanFactory 的类体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96BeanFactory"><span class="nav-number">5.1.2.</span> <span class="nav-text">初始化BeanFactory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.2.</span> <span class="nav-text">ApplicationContext介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationContext%E7%9A%84%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">ApplicationContext的类体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebApplicationContext-%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.2.</span> <span class="nav-text">WebApplicationContext 类体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebApplicationContext-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.3.</span> <span class="nav-text">WebApplicationContext 初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">父子容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.</span> <span class="nav-text">Bean的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.1.</span> <span class="nav-text">BeanFactory中Bean的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%A7%A3"><span class="nav-number">6.1.1.</span> <span class="nav-text">生命周期图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%A5%E6%8E%A2-Bean-%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">窥探 Bean ⽣命周期的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Bean-%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A5%E2%BC%9D%E7%9A%84%E6%8E%A2%E8%AE%A8"><span class="nav-number">6.1.3.</span> <span class="nav-text">关于 Bean ⽣命周期接⼝的探讨</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AplicationContext-%E4%B8%AD-Bean-%E7%9A%84%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.2.</span> <span class="nav-text">AplicationContext 中 Bean 的⽣命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">星之辰</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://angryxzc.github.io/2024/05/14/%E7%B2%BE%E9%80%9ASpring4-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-Chapter04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="星之辰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星之辰的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="精通Spring4.x企业应用开发实战-Chapter04 | 星之辰的博客">
      <meta itemprop="description" content="Spring的核心容器(IoC)">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          精通Spring4.x企业应用开发实战-Chapter04
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-14 09:07:08" itemprop="dateCreated datePublished" datetime="2024-05-14T09:07:08+08:00">2024-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-12 10:23:30" itemprop="dateModified" datetime="2024-06-12T10:23:30+08:00">2024-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

            <div class="post-description">Spring的核心容器(IoC)</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><ul>
<li>IoC概念所包含的设计思想</li>
<li>Java 反射技术</li>
<li>BeanFactory、ApplicationContext 及 WebApplicationContext 基础接口</li>
<li>Bean的⽣命周期</li>
</ul>
<h2 id="IoC概述"><a href="#IoC概述" class="headerlink" title="IoC概述"></a>IoC概述</h2><p>IoC（Inverse of Control，控制反转）是 Spring 容器的内核，AOP、声明式事务等功<br>能在此基础上开花结果。IoC确实包括很多内涵，它涉及代码解耦、设计模式、代码优化等问题的考量，下面试图通过⼀个⼩例⼦来说明这个概念。</p>
<h3 id="通过实例理解IoC概念"><a href="#通过实例理解IoC概念" class="headerlink" title="通过实例理解IoC概念"></a>通过实例理解IoC概念</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>张之亮的《墨攻》，中有⼀个场景，当刘德华所饰演的墨者城上梁国守军问道：“来者何⼈？”刘德华回答：“墨者⾰离！”我们不妨通过Java语⾔这个“城门叩问”的场景编写剧本，并借此理解IoC的概念，</p>
<h4 id="直接的想法"><a href="#直接的想法" class="headerlink" title="直接的想法"></a>直接的想法</h4><p>直接使用演员编排剧本，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoAttack</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityGateAsk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ①演员直接侵入剧本</span></span><br><span class="line">        <span class="type">LiuDeHua</span> <span class="variable">ldh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">        ldh.responseAsk(<span class="string">&quot;墨者⾰离！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，以上剧本在①处，作为具体⻆⾊饰演者的刘德华直接侵⼊剧本，使剧本和演员直接耦合在⼀起，如下图所示：</p>
<pre class="mermaid">    classDiagram
    class MoAttack{
        +cityGateAsk() void
    }
    class LiuDeHua{
        +responseAsk(String) void
    }
    MoAttack ..> LiuDeHua</pre>

<h4 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h4><ul>
<li>剧本和演员直接耦合在⼀起，不利于剧本的维护和演员的替换。</li>
</ul>
<h4 id="通过角色编排剧本"><a href="#通过角色编排剧本" class="headerlink" title="通过角色编排剧本"></a>通过角色编排剧本</h4><p>⼀个明智的编剧在剧情创作时应围绕故事的⾓⾊进⾏，⽽不应考虑⾓⾊的具体饰演者，这样才可能在剧本投拍时⾃由地遴选任何适合的演员，⽽⾮绑定在某⼀⼈⾝上。通过以上分析，我们知道需要为该剧本的主⼈公⾰离定义⼀个接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoAttack</span>()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityGateAsk</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// ①引入革离角色接口</span></span><br><span class="line">         <span class="type">GeLi</span> <span class="variable">geli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">       <span class="comment">// ②通过接口展开剧情</span></span><br><span class="line">       geli.responseAsk(<span class="string">&quot;墨者⾰离！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在①处引⼊了剧本的⻆⾊—⾰离，剧本的情节通过⻆⾊展开，在拍摄时⻆⾊由演员饰演，如②处所示。因此，墨攻、⾰离、刘德华三者的类图关系如图所示：</p>
<p>引入角色接口后的关系：</p>
<pre class="mermaid">

classDiagram
class MoAttack{
    +cityGateAsk() void
}
class GeLi{
    &lt;&lt;interface&gt;&gt;
    +responseAsk(String) void
}
class LiuDeHua{
    +responseAsk(String) void
}
MoAttack ..&gt; GeLi : created
MoAttack ..&gt; LiuDeHua
GeLi &lt;|.. LiuDeHua
</pre>

<h4 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h4><ul>
<li><p>MoAttack 同时依赖于 GeLi接口和 LiuDeHua 类，并没有达到我们所期望的剧本仅依赖于⾓⾊的⽬的。</p>
</li>
<li><p>通过引入接⼝，剧本和演员之间的耦合度降低，但是剧本和演员之间的关系还是在剧本中硬编码的，不利于剧本的维护和演员的替换。</p>
</li>
<li><p>为了解决这个问题，在影⽚投拍时，导演将 LiuDeHlua 安排在GeLi 的⾓⾊上，导演负责剧本、⾓⾊、饰演者三者的协调控制，如图：</p>
<p>剧本和饰演者解耦</p>
<pre class="mermaid">

classDiagram
directation LR
class MoAttack{
    +cityGateAsk() void
}
class GeLi{
    &lt;&lt;interface&gt;&gt;
    +responseAsk() void
}
class LiuDeHua{
    +responseAsk() void
}
class Director{
    +derectMoive() void
}
Director ..&gt; MoAttack
Director ..&gt; GeLi
Director ..&gt; LiuDeHua :create
MoAttack ..&gt; GeLi
LiuDeHua ..|&gt; GeLi

 
</pre></li>
</ul>
<p>通过引⼊导演，使得剧本和具体饰演者解耦。对应到软件中，导演就像⼀台装配器， 安排演员表演具体的⾓⾊。</p>
<p>现在我们可以反过来讲解IoC 的概念了。IoC （Inverse of Control）的字⾯意思是控 制反转，它包括两⽅⾯的内容：</p>
<ul>
<li>控制：指的是⼀个对象对另⼀个对象的使⽤，即对另⼀个对象的控制。</li>
<li>反转：指的是获得⼀个对象的⽅式反转了，即原来⼀个对象是通过 new 的⽅式获得的，反转后是通过容器来获得。</li>
</ul>
<p>那到底是什么东西的“控制”被“反转”了呢？对应到前⾯的例⼦，</p>
<ul>
<li>“控制”是指选择 GeLi⾓⾊扮演者的控制权；</li>
<li>“反转”是指这种控制权从《墨攻》剧本中移除，转交 到导演的⼿中。对于软件来说，即某⼀接口具体实现类的选择控制权从调⽤类中移除， 转交给第三⽅决定，即由 Spring 容器借由 Bean 配置来进⾏控制。</li>
</ul>
<p><span style="color:cadetblue">因为IoC确实不够开门见⼭，因此业界曾进⾏了⼴泛的讨论，最终软件界的泰⽃级 ⼈物 Martin Fowler 提出了 DI （Dependency Injection，依赖注⼊）的概念⽤来代替IoC， 即让调⽤类对某⼀接口实现类的依赖关系由第三⽅（容器或协作类）注⼊，以移除调⽤类对某⼀接口实现类的依赖。“依赖注⼊”这个名词显然⽐“控制反转”直接明了、易于理解。</span></p>
<h3 id="IoC的类型"><a href="#IoC的类型" class="headerlink" title="IoC的类型"></a>IoC的类型</h3><p>从注⼊⽅法上看，IoC 主要可以划分为3种类型：构造函数注⼊、属性注⼊和接口注⼊。Spring ⽀持构造函数注⼊和属性注⼊。下⾯我们继续使⽤以上的例⼦说明这3种注⼊⽅式的区别。</p>
<ol>
<li><p>构造函数注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoAttack</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> GeLi geli;</span><br><span class="line">    <span class="comment">// ①构造函数注入,注入革离具体饰演者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MoAttack</span><span class="params">(GeLi geli)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.geli = geli;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityGateAsk</span><span class="params">()</span>&#123;</span><br><span class="line">        geli.responseAsk(<span class="string">&quot;墨者⾰离！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MoAttack 的构造函数不关⼼具体由谁来饰演⾰离这个⾓⾊，只要在①处传⼊的饰 演者按剧本要求完成相应的表演即可，⾓⾊的具体饰演者由导演来安排，如代码所⽰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directMoive</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">// ①导演安排演员</span></span><br><span class="line">        <span class="type">GeLi</span> <span class="variable">geli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">     <span class="comment">// ②导演指定剧本</span></span><br><span class="line">        <span class="type">MoAttack</span> <span class="variable">moAttack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MoAttack</span>(geli);</span><br><span class="line">        moAttack.cityGateAsk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoAttack</span>()&#123;</span><br><span class="line">     <span class="keyword">private</span> GeLi geli;</span><br><span class="line">     <span class="comment">// ①属性注入,注入革离具体饰演者</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGeLi</span><span class="params">(GeLi geli)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.geli = geli;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityGateAsk</span><span class="params">()</span>&#123;</span><br><span class="line">          geli.responseAsk(<span class="string">&quot;墨者⾰离！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> MoAttack 在①处为 geli 属性提供了⼀个 Setter ⽅法，以便让导演在需要时注⼊geli的具体饰演者，如代码所⽰。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directMoive</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MoAttack</span> <span class="variable">moAttack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MoAttack</span>();</span><br><span class="line">        <span class="comment">// ①调用属性Setter方法注入</span></span><br><span class="line">        <span class="type">GeLi</span> <span class="variable">geli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">        moAttack.setGeLi(geli);</span><br><span class="line">        moAttack.cityGateAsk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 和通过构造函数注⼊⾰离饰演者不同，在实例化MoAttack 剧本时，并未指定任何饰演者，⽽是在实例化 MoAttack 后，在需要⾰离出场时，才调⽤其 setGeli（⽅法注⼊饰演者。按照类似的⽅式，还可以分别为剧本中的其他诸如梁王、巷淹中等⻆⾊提供注⼊的 Setter ⽅法，这样，导演就可以根据所拍剧段的不同，按需注⼊相应的⾓⾊。</p>
</li>
<li><p>接口注入<br>将调⽤类所有依赖注⼊的⽅法抽取到⼀个接口中，调⽤类通过实现该接口提供相应的注⼊⽅法。为了采取接口注⼊的⽅式，必须先声明⼀个 ActorArrangable 接口，如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActorArrangable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">injectGeLi</span><span class="params">(GeLi geli)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后，MoAttack 通过 ActorArrangable 接口提供具体的实现，如代码清单：</p>
<p> 通过接口注入革离饰演者</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoAttack</span> <span class="keyword">implements</span> <span class="title class_">ActorArrangable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GeLi geli;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">injectGeLi</span><span class="params">(GeLi geli)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.geli = geli;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cityGateAsk</span><span class="params">()</span>&#123;</span><br><span class="line">        geli.responseAsk(<span class="string">&quot;墨者⾰离！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Director 类通过调⽤ ActorArrangable 接口的 injectGeLi ⽅法来注⼊具体的饰演者，如代码所⽰：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directMoive</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MoAttack</span> <span class="variable">moAttack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MoAttack</span>();</span><br><span class="line">        <span class="type">GeLi</span> <span class="variable">geli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiuDeHua</span>();</span><br><span class="line">        <span class="comment">// ①接口注入</span></span><br><span class="line">        moAttack.injectGeLi(geli);</span><br><span class="line">        moAttack.cityGateAsk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><span style="color:cadetblue">由于通过接⼝注⼊需要额外声明⼀个接⼝，增加了类的数⽬，⽽且它的效果和属性 注⼊并⽆本质区别，因此我们不提倡采⽤这种注⼊⽅式。</span></p>
<h3 id="通过容器完成依赖关系注入"><a href="#通过容器完成依赖关系注入" class="headerlink" title="通过容器完成依赖关系注入"></a>通过容器完成依赖关系注入</h3><p>虽然 MoAttack 和 LiuDeHua 实现了解耦，MoAttack ⽆须关注⻆⾊实现类的实例化 ⼯作，但这些⼯作在代码中依然存在，只是转移到 Director 类中⽽已。假设某⼀制⽚⼈<br>想改变这⼀局⾯，在选择某个剧本后，希望通过媒体“海选”或者第三⽅代理机构来选 择导演、演员，让他们各司其职，那么剧本、导演、演员就都实现了解耦。虽然 MoAttack 和 LiuDeHua 实现了解耦，MoAttack ⽆须关注⻆⾊实现类的实例化 ⼯作，但这些⼯作在代码中依然存在，只是转移到 Director 类中⽽已。假设某⼀制⽚⼈想改变这⼀局⾯，在选择某个剧本后，希望通过媒体“海选”或者第三⽅代理机构来选 择导演、演员，让他们各司其职，那么剧本、导演、演员就都实现了解耦。</p>
<p>所谓媒体“海选”和第三⽅代理机构，在程序领域就是⼀个第三⽅的容器，它帮助 完成类的初始化与装配⼯作，让开发者从这些底层实现类的实例化、依赖关系装配等⼯作 中解脱出来，专注于更有意义的业务逻辑开发⼯作。这⽆疑是⼀件令⼈向往的事情。Spring 就是这样的⼀个容器，它通过配置⽂件或注解描述类和类之间的依赖关系，⾃动完成类的 初始化和依赖注⼊⼯作。下⾯是Spring 配置⽂件对以上实例进⾏配置的配置⽂件⽚段：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--①实现类的实例化--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;geli&quot;</span> <span class="attr">class</span>=<span class="string">&quot;LiuDeHua&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;moAttack&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.ioc.MoAttack&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">p:geli-ref</span>=<span class="string">&quot;geli&quot;</span>/&gt;</span> <span class="comment">&lt;!--②通过geli-ref建立依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 new XmlBeanFactory（”beans.xml”）等⽅式即可启动容器。在容器启动时，Spring根据配置⽂件的描述信息，⾃动实例化 Bean 并完成依赖关系的装配，从容器中即可返 回准备就绪的 Bean 实例，后续可直接使⽤之。</p>
<p>Spring 为什么会有这种“神奇”的⼒量，仅凭⼀个简单的配置⽂件，就能魔法般地 实例化并装配好程序所⽤的Bean呢？这种“神奇”的⼒量归功于Java 语⾔本⾝的类反 射功能。</p>
<h2 id="相关Java基础知识"><a href="#相关Java基础知识" class="headerlink" title="相关Java基础知识"></a>相关Java基础知识</h2><p>Java 语⾔允许通过程序化的⽅式间接对Class 进⾏操作。Class ⽂件由类装载器装载 后，在JVM 中将形成⼀份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息，如构造函数、属性和⽅法等。Java 允许⽤户借由这个与 Class 相关 的元信息对象间接调⽤ Class 对象的功能，这就为使⽤程序化⽅式操作 Class 对象开辟了途径。</p>
<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>简单的例⼦开始探访Java 反射机制的征程。下⾯的Car 类拥有两个构造函数、⼀个⽅法及3个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> maxSpeed;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//①默认构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;init car!!&quot;</span>);&#125;</span><br><span class="line"> <span class="comment">//②带参构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand,String color,<span class="type">int</span> maxSpeed)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">  <span class="built_in">this</span>.maxSpeed = maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//③未带参的方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;brand:&quot;</span>+brand+<span class="string">&quot;;color:&quot;</span>+color+<span class="string">&quot;;maxSpeed:&quot;</span>+maxSpeed);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> brand;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxSpeed</span><span class="params">(<span class="type">int</span> maxSpeed)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.maxSpeed = maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⼀般情况下，我们会使⽤如下代码创建Car 的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car.serBrand(<span class="string">&quot;红旗CA72&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;红旗CA72&quot;</span>,<span class="string">&quot;红色&quot;</span>,<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>以上两种⽅法都采⽤传统⽅式直接调⽤⽬标类的⽅法。下⾯我们通过Java 反射机制以⼀种间接的⽅式操控⽬标类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/4/12 09 52:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Car <span class="title function_">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ①通过类装载器获取Car类对象</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;com.smart.reflect.Car&quot;</span>);</span><br><span class="line">        <span class="comment">// ②获取类的默认构造器对象并通过它实例化Car</span></span><br><span class="line">        Constructor cons=clazz.getDeclaredConstructor((Class[])<span class="literal">null</span>);</span><br><span class="line">        Car car=(Car) cons.newInstance();</span><br><span class="line">        <span class="comment">// ③通过反射方法设置属性</span></span><br><span class="line">        Method setBrand= clazz.getMethod(<span class="string">&quot;setBrand&quot;</span>, String.class);</span><br><span class="line">        setBrand.invoke(car, <span class="string">&quot;红旗CA72&quot;</span>);</span><br><span class="line">        Method setColor= clazz.getMethod(<span class="string">&quot;setColor&quot;</span>, String.class);</span><br><span class="line">        setColor.invoke(car, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        Method setMaxSpeed= clazz.getMethod(<span class="string">&quot;setMaxSpeed&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        setMaxSpeed.invoke(car, <span class="number">200</span>);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> initByDefaultConst();</span><br><span class="line">        car.introduce();</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="comment">//        System.out.println(&quot;loader:&quot;+loader);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;loader parent:&quot;+loader.getParent());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;loader parent parent:&quot;+loader.getParent().getParent());</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;com.smart.reflect.PrivateCar&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrivateCar</span> <span class="variable">privateCar</span> <span class="operator">=</span> (PrivateCar) clazz.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">colorField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">        <span class="comment">// 取消Java语言访问检查以访问private变量</span></span><br><span class="line">        colorField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        colorField.set(privateCar, <span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">driveMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drive&quot;</span>, (Class[])<span class="literal">null</span>);</span><br><span class="line">        driveMethod.invoke(privateCar, (Object[])<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行以上程序：<br>控制台输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init car!!</span><br><span class="line">brand:红旗CA72;color:黑色;maxSpeed:200</span><br><span class="line">drive private car! the color is:红色</span><br></pre></td></tr></table></figure>

<p>这说明我们完全可以通过编程⽅式调⽤ Class 的各项功能，与通过构造函数和⽅法 直接调⽤类功能的效果是⼀致的，只不过前者是间接调⽤，后者是直接调⽤罢了。</p>
<p>在 ReflectTest 中使⽤了⼏个重要的反射类，分别是:</p>
<ul>
<li>ClassLoader、</li>
<li>Class、</li>
<li>Constructor</li>
<li>Method</li>
</ul>
<p>通过这些反射类就可以间接调⽤⽬标Class 的各项功能。在①处，我们获取<br>当前线程的 ClassLoader，然后通过指定的全限定类名 “com.smart.beans.Car”装载Car类对应的反射实例。</p>
<p>在②处，我们通过Car的反射类对象获取Car的构造函数对象cons，通过构造函数对象的 <code>newInstrance（）</code>⽅法实例化 Car 对象，其效果等同于 <code>new Car（）</code>。</p>
<p>在 ③处，我们⼜通过Car 的反射类对象的 getMethod（String methodName,Class paramClass）</p>
<p>获取属性的 Setter ⽅法对象:</p>
<p>其中第⼀个参数是⽬标Class 的⽅法名；第⼆个参数是⽅法⼊参的对象类型。在获取⽅法反射对象后，即可通过 invoke（Object obj,Object param） ⽅法调⽤⽬标类的⽅法，该⽅法的第⼀个参数是操作的⽬标类对象实例，第⼆个参数是 ⽬标⽅法</p>
<p>将函数封装起来，把包名，路径，以及调用方以⼀个配置⽂件的⽅式提供，就可以使⽤ Java 语⾔的反射功能编写 ⼀段通⽤的代码，对类似于Car 的类进⾏实例化及功能调⽤操作。</p>
<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3><h4 id="类装载器的工作机制"><a href="#类装载器的工作机制" class="headerlink" title="类装载器的工作机制"></a>类装载器的工作机制</h4><p>类装载器就是寻找类的节码⽂件并构造出类在JVM内部表⽰对象的组件。在 Java 中，类装载器把⼀个类装⼊JVM 中，需要经过以下步骤：</p>
<ol>
<li>装载：查找和导⼊ Class ⽂件。</li>
<li>链接：执⾏校验、准备和解析步骤，其中解析步骤是可以选择的。<ol>
<li>校验：检查载⼊ Class ⽂件数据的正确性。</li>
<li>准备：给类的静态变量分配存储空间</li>
<li>解析：将符号引⽤转换成直接引⽤。</li>
</ol>
</li>
<li>初始化：对类的静态变量、静态代码块执⾏初始化⼯作。</li>
</ol>
<p>类装载⼯作由 ClassLoader 及其⼦类负责。ClassLoader 是⼀个重要的 Java运⾏时系统组件，它负责在运⾏时查找和装⼊Class 字节码⽂件。JVM 在运⾏时会产⽣3个ClassLoader：</p>
<ol>
<li>根装载器、</li>
<li>ExtClassLoader（扩展类装载器）</li>
<li>AppClassLoader（应⽤类装 载器）。</li>
</ol>
<p>其中，根装载器不是 ClassLoader 的⼦类，它使⽤ C++语⾔编写，因⽽在 Java 中 看不到它，根装载器负责装载JRE的核⼼类库，如JRE⽬标下的 rt.jar、charsets.jar 等。<br>ExtClassL oader 和 AppClassLoader 都是 ClassLoader 的⼦类，</p>
<p>其中 ExtClassLoader 负责装 载JRE扩展⽬录 ext 中的JAR类包；</p>
<p>AppClassLoader 负责装载 Classpath 路径下的类包。</p>
<p>这3个类装载器之间存在⽗⼦层级关系，即根装载器是 ExtClassLoader 的⽗装载器， ExtClassLoader 是 AppClassLoader 的⽗装载器。在默认情况下，使⽤ AppClassLoader装 载应⽤程序的类。我们可以做⼀个实验，如代码所⽰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/4/12 09 52:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> t &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;loader:&quot;</span>+loader);</span><br><span class="line">        System.out.println(<span class="string">&quot;loader parent:&quot;</span>+loader.getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;loader parent parent:&quot;</span>+loader.getParent().getParent());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上程序，控制台输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">loader parent:sun.misc.Launcher$ExtClassLoader@60e53b93</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">①根装载器在Java中访问不到，所以返回nu11</span></span><br><span class="line">loader parent parent:null</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>通过以上输出信息，我们知道当前的 ClassLoader 是 AppClassLoader，其⽗<br>ClassLoader 是 ExtClassLoader，祖⽗ ClassLoader 是根装载器，因为在 Java 中⽆法获得它的句柄，所以仅返回 null。</p>
<p><span style="color:cadetBlue">JVM 装载类时使⽤“全盘负责委托机制”，“全盘负责”是指当⼀个 ClassLoader 装 载⼀个类时，除⾮显式地使⽤另⼀个 ClassLoader，该类所依赖及引⽤的类也由这个 ClassLoader 载⼊；“委托机制”是指先委托⽗装载器寻找⽬标类，只有在找不到的情况 下才从⾃⼰的类路径中查找并装载⽬标类。这⼀点是从安全⾓度考虑的，试想，如果有 ⼈编写了⼀个恶意的基础类（如 java.lang.String）并装载到JVM中，将会引起多么可怕 的后果？但是由于有了“全盘负责委托机制”，java.lang.String 永远是由根装载器来装载 的，这样就避免了上述安全隐患的发⽣。</span></p>
<h4 id="ClassLoader-的重要⽅法"><a href="#ClassLoader-的重要⽅法" class="headerlink" title="ClassLoader 的重要⽅法"></a>ClassLoader 的重要⽅法</h4><p>在Java 中，ClassLoader 是⼀个抽象类，位于java.lang 包中。下⾯对该类的⼀些重要接⼝⽅法进⾏介绍。</p>
<ul>
<li><code>Class loadClass（String name）</code>：name 参数指定类装载器需要装载类的名字，必须使⽤全限定类名，如 com.smart. beans.Car。该⽅法有⼀个重载⽅法 loadClass（String name,boolean resolve），resolve 参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进⾏类解析的⼯作，但并不是所有的类都需要解析。如果JVM 只需要知道该类是否存在或找出该类的超类，那么就不需要进⾏解析。</li>
<li><code>Class defineClass（String name, byte［］b, int off, int len）</code>：将类⽂件的字节数组转换成JVM 内部的 java.lang.Class 对象。字节数组可以从本地⽂件系统、远程⽹络 获取。参数 name 为字节数组对应的全限定类名。  </li>
<li><code>Class findSystemClass（String name）</code>：从本地⽂件系统载⼊Class ⽂件。如果本地 ⽂件系统不存在该 Class ⽂件，则将抛出 ClassNotFoundException 异常。该⽅法 是JVM 默认使⽤的装载机制。</li>
<li><code>Class findLoadedClass（String name）</code>：调⽤该⽅法来查看 ClassLoader 是否已装⼊ 某个类。如果已装⼊，那么返回 java.lang.Class 对象；否则返回 null。如果强⾏ 装载已存在的类，那么将会抛出链接错误。 ⼜</li>
<li><code>ClassLoader getParentO）</code>：获取类装载器的⽗装载器。除根装载器外，所有的类装载器都有且仅有⼀个⽗装载器。</li>
<li><code>ExtClassLoader</code> 的⽗装载器是根装载器，因为根装载器⾮Java 语⾔编写，所以⽆法获得，将返回 null。</li>
<li>除JVM默认的3个 ClassLoader 外，⽤户可以编写⾃⼰的第三⽅类装载器，以实现 ⼀些特殊的需求。类⽂件被装载并解析后，在JVM 内将拥有⼀个对应的java.lang.Class 类描述对象，该类的实例都拥有指向这个类描述对象的引⽤，⽽类描述对象又拥有指向 关联 ClassLoader 的引⽤，如图</li>
</ul>
<p><img src="/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%B1%BB%E5%AE%9E%E4%BE%8B-%E7%B1%BB%E6%8F%8F%E8%BF%B0-%E8%A3%85%E8%BD%BD%E5%99%A8.png" alt="source/images/spring/Spring4.x_企业开发实战/类实例-类描述-装载器"></p>
<p>每个类在JVM 中都拥有⼀个对应的 java.lang.Class 对象，它提供了类结构信息的描述。数组、枚举、注解及基本 Java 类型（如 int、double 等），甚⾄ void 都拥有对应的 Class 对象。Class没有public 的构造⽅法。Class 对象是在装载类时由JVM通过调⽤类装载器中的 defineClass（）⽅法⾃动构造的。</p>
<h3 id="Java-反射机制"><a href="#Java-反射机制" class="headerlink" title="Java 反射机制"></a>Java 反射机制</h3><p>Class 反射对象描述类语义结构，可以从 Class 对象中获取构造函数、成员变量、⽅法类等类元素的反射对象，并以编程的⽅式通过这些反射对象对⽬标类对象进⾏操作。 这些反射对象类在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">java.lang.reflect</a> 包中定义。下⾯介绍3个主要的反射类。</p>
<ol>
<li>Constructor：描述类的构造函数。</li>
<li>Method：描述类的⽅法。</li>
<li>Field：描述类的成员变量。</li>
</ol>
<p>此外，Java 还为包提供了 Package 反射类，在 Java 5.0 中还为注解提供了AnnotatedElement 反射类。总之，Java 的反射体系保证了可以通过程序化的⽅式访问⽬标类中所有的元素，对于 private 或 protected 成员变量和⽅法，只要JVM的安全机制允许，也可以通过反射进⾏调⽤,如代码所⽰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateCar</span> &#123;</span><br><span class="line">    <span class="comment">// private成员变量：使用传统的类实例调用方式，只能在本类中访问</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">// protected方法：使用传统的类实例调用方式，只能在子类和本包中访问</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;drive private car! the color is:&quot;</span>+color);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>color 变量和 drive0⽅法都是私有的，通过类实例变量⽆法在外部访问私有变量、请⽤私有⽅法，但通过反射机制则可以绕过这个限制，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;com.smart.reflect.PrivateCar&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">PrivateCar</span> <span class="variable">privateCar</span> <span class="operator">=</span> (PrivateCar) clazz.newInstance();</span><br><span class="line">      <span class="type">Field</span> <span class="variable">colorField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">      <span class="comment">// 取消Java语言访问检查以访问private变量</span></span><br><span class="line">      colorField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      colorField.set(privateCar, <span class="string">&quot;红色&quot;</span>);</span><br><span class="line">      <span class="type">Method</span> <span class="variable">driveMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drive&quot;</span>, (Class[])<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 取消Java语言访问检查以访问protected方法</span></span><br><span class="line">      driveMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      driveMethod.invoke(privateCar, (Object[])<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行以上程序，控制台输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drive private car! the color is:红色</span><br></pre></td></tr></table></figure>

<p>在访问 private或 protected 成员变量和⽅法时，必须通过 setAccessible（boolean access）⽅法取消 Java 语⾔检查，否则将拋出 IIlegalAccessException。如果 JVM 的安全管理器设置了相应的安全机制，那么调⽤该⽅法将抛出 SecurityException。</p>
<h2 id="资源访问利器"><a href="#资源访问利器" class="headerlink" title="资源访问利器"></a>资源访问利器</h2><h3 id="资源抽象接口"><a href="#资源抽象接口" class="headerlink" title="资源抽象接口"></a>资源抽象接口</h3><p>JDK 所提供的访问资源的类（如 java.net.URL、File 等）并不能很好地满⾜各种底 层资源的访问需求，⽐如缺少从类路径或者 Web 容器的上下⽂中获取资源的操作类。鉴于此，Spring 设计了⼀个 Resource 接⼝，它为应⽤提供了更强的底层资源访问能⼒。 该接⼝拥有对应不同资源类型的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.core.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    URI <span class="title function_">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Resource 接⼝定义了⼀系列访问资源的⽅法:</p>
<ul>
<li>boolean existsO：资源是否存在。</li>
<li>boolean isOpen（）：资源是否打开。</li>
<li>URL getURL（ throws IOException：如果底层资源可以表⽰成 URL，则该⽅法返回对应的URL 对象。</li>
<li>File getFile（ throws IOException：如果底层资源对应⼀个⽂件，则该⽅法返回对应的 File 对象。</li>
<li>InputStream getlnputStream（） throws IOException： 返回资源对应的输⼊流。</li>
</ul>
<p>Resource 在 Spring 框架中起着不可或缺的作⽤，Spring 框架使⽤ Resource 装载各种 资源，包括配置⽂件资源、国际化属性⽂件资源等。下⾯我们来了解⼀下 Resource 的具体实现类【<span style="color:cadetBlue">从IDEA中导出的mermaid图，这里的实线继承，虚线实线接口</span>】：</p>
<pre class="mermaid">

classDiagram
direction BT
class AbstractFileResolvingResource {

+ contentLength() long
+ lastModified() long
+ exists() boolean

# customizeConnection(URLConnection) void

# customizeConnection(HttpURLConnection) void

# getFile(URI) File

   File file
   File fileForLastModifiedCheck
   boolean readable
}
class AbstractResource {

+ equals(Object) boolean
+ exists() boolean
+ toString() String
+ hashCode() int
+ lastModified() long
+ contentLength() long
+ createRelative(String) Resource
   File file
   File fileForLastModifiedCheck
   boolean open
   URI URI
   URL URL
   String filename
   boolean readable
}
class BeanDefinitionResource {
+ exists() boolean
+ equals(Object) boolean
+ hashCode() int
   String description
   InputStream inputStream
   boolean readable
   BeanDefinition beanDefinition
}
class ByteArrayResource {
+ hashCode() int
+ equals(Object) boolean
+ exists() boolean
+ contentLength() long
   InputStream inputStream
   String description
   byte[] byteArray
}
class ClassPathResource {
+ hashCode() int

# resolveURL() URL

+ equals(Object) boolean
+ createRelative(String) Resource
+ exists() boolean
   String description
   URL URL
   String filename
   ClassLoader classLoader
   InputStream inputStream
   String path
}
class ContextResource {
&lt;&lt;Interface&gt;&gt;
   String pathWithinContext
}
class DescriptiveResource {
+ exists() boolean
+ equals(Object) boolean
+ hashCode() int
   InputStream inputStream
   String description
   boolean readable
}
class FileSystemResource {
+ createRelative(String) Resource
+ equals(Object) boolean
+ exists() boolean
+ hashCode() int
+ contentLength() long
   File file
   String description
   OutputStream outputStream
   boolean writable
   URI URI
   URL URL
   String filename
   InputStream inputStream
   boolean readable
   String path
}
class InputStreamResource {
+ equals(Object) boolean
+ exists() boolean
+ hashCode() int
   InputStream inputStream
   String description
   boolean open
}
class InputStreamSource {
&lt;&lt;Interface&gt;&gt;
   InputStream inputStream
}
class PathResource {
+ exists() boolean
+ lastModified() long
+ hashCode() int
+ contentLength() long
+ equals(Object) boolean
+ createRelative(String) Resource
   File file
   String description
   OutputStream outputStream
   boolean writable
   URI URI
   URL URL
   String filename
   InputStream inputStream
   boolean readable
   String path
}
class Resource {
&lt;&lt;Interface&gt;&gt;
+ contentLength() long
+ exists() boolean
+ lastModified() long
+ createRelative(String) Resource
   File file
   String description
   boolean open
   URI URI
   URL URL
   String filename
   boolean readable
}
class UrlResource {

+ getCleanedUrl(URL, String?) URL

+ equals(Object) boolean
+ hashCode() int
+ createRelative(String) Resource
   File file
   String description
   URI URI
   URL URL
   String filename
   InputStream inputStream
}
class VfsResource {
+ createRelative(String) Resource
+ equals(Object) boolean
+ hashCode() int
+ exists() boolean
+ lastModified() long
+ contentLength() long
   File file
   String description
   URI URI
   URL URL
   String filename
   InputStream inputStream
   boolean readable
}
class WritableResource {
&lt;&lt;Interface&gt;&gt;
   OutputStream outputStream
   boolean writable
}

AbstractFileResolvingResource  --&gt;  AbstractResource
AbstractResource  ..&gt;  Resource
BeanDefinitionResource  --&gt;  AbstractResource
ByteArrayResource  --&gt;  AbstractResource
ClassPathResource  --&gt;  AbstractFileResolvingResource
ContextResource  --&gt;  Resource
DescriptiveResource  --&gt;  AbstractResource
FileSystemResource  --&gt;  AbstractResource
FileSystemResource  ..&gt;  WritableResource
InputStreamResource  --&gt;  AbstractResource
PathResource  --&gt;  AbstractResource
PathResource  ..&gt;  WritableResource
Resource  --&gt;  InputStreamSource
UrlResource  --&gt;  AbstractFileResolvingResource
VfsResource  --&gt;  AbstractResource
WritableResource  --&gt;  Resource
</pre>

<p>简略版：</p>
<pre class="mermaid">

classDiagram
direction BT
class AbstractFileResolvingResource
class AbstractResource
class BeanDefinitionResource
class ByteArrayResource
class ClassPathResource
class ContextResource {
&lt;&lt;Interface&gt;&gt;

}
class DescriptiveResource
class FileSystemResource
class InputStreamResource
class InputStreamSource {
&lt;&lt;Interface&gt;&gt;

}
class PathResource
class Resource {
&lt;&lt;Interface&gt;&gt;

}
class UrlResource
class VfsResource
class WritableResource {
&lt;&lt;Interface&gt;&gt;

}

AbstractFileResolvingResource  --&gt;  AbstractResource
AbstractResource  ..&gt;  Resource
BeanDefinitionResource  --&gt;  AbstractResource
ByteArrayResource  --&gt;  AbstractResource
ClassPathResource  --&gt;  AbstractFileResolvingResource
ContextResource  --&gt;  Resource
DescriptiveResource  --&gt;  AbstractResource
FileSystemResource  --&gt;  AbstractResource
FileSystemResource  ..&gt;  WritableResource
InputStreamResource  --&gt;  AbstractResource
PathResource  --&gt;  AbstractResource
PathResource  ..&gt;  WritableResource
Resource  --&gt;  InputStreamSource
UrlResource  --&gt;  AbstractFileResolvingResource
VfsResource  --&gt;  AbstractResource
WritableResource  --&gt;  Resource
</pre>

<ul>
<li>WritableResource： 可写资源接口，是Spring 3.1 版本新加的接口，有两个实现类，即FileSystemResource 和 PathResource，其中 PathResource 是Spring 4.0提供的实现类。</li>
<li>ByteArrayResource： ⼆进制数组表⽰的资源，⼆进制数组资源可以在内存中通过程序构造</li>
<li>ClassPathResource：类路径下的资源，资源以相对于类路径的⽅式表⽰，如代码一下示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSourceExample</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/Users/xzc/Documents/java-relative/SpringStudy/SpringLearn4.x/Spring4x/chapter4/src/main/resources/conf/file1.txt&quot;</span>;</span><br><span class="line">   <span class="comment">//①.使⽤系统⽂件路径方式加载⽂件</span></span><br><span class="line">   <span class="type">WritableResource</span> <span class="variable">res1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathResource</span>(filePath);</span><br><span class="line">    <span class="comment">//②.使⽤类路径方式加载⽂件</span></span><br><span class="line">   <span class="type">Resource</span> <span class="variable">res2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;conf/file1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//③.使⽤WritableResource 接⼝写资源⽂件</span></span><br><span class="line">   <span class="type">OutputStream</span> <span class="variable">stream1</span> <span class="operator">=</span> res1.getOutputStream();</span><br><span class="line">   stream1.write(<span class="string">&quot;欢迎光临\n小春论坛&quot;</span>.getBytes());</span><br><span class="line">   stream1.close();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//④.使⽤Resource 接⼝读资源⽂件</span></span><br><span class="line">   <span class="type">InputStream</span> <span class="variable">ins1</span> <span class="operator">=</span> res1.getInputStream();</span><br><span class="line">   <span class="type">InputStream</span> <span class="variable">ins2</span> <span class="operator">=</span> res2.getInputStream();</span><br><span class="line"></span><br><span class="line">   <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">while</span>((i=ins1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(i);</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;res1:&quot;</span>+res1.getFilename());</span><br><span class="line">            System.out.println(<span class="string">&quot;res2:&quot;</span>+res2.getFilename());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FileSystemResource：⽂件系统资源，资源以⽂件系统路径的⽅式表⽰，如<code>D:/conf/bean.xml</code> 等。</li>
<li>InputStreamResource：以输⼊流返回表⽰的资源。</li>
<li>ServletContextResource：为访问 Web 容器上下⽂中的资源⽽设计的类，负责以相对于 Web 应⽤根⽬录的路径加载资源。它⽀持以流和 URL 的⽅式访问，在WAR 解包的情况下，也可以通过 File ⽅式访问。该类还可以直接从JAR 包中访问资源。</li>
<li>UriResource: URL 封装了 java.net.URL，它使⽤户能够访问任何可以通过 URL表⽰的资源，如⽂件系统的资源、HTTP 资源、FTP 资源等。</li>
<li>PathResource: Spring 4.0提供的读取资源⽂件的新类。Path 封装了 java.net.URL、<br>java.nio.file.Path（Java 7.0提供）、⽂件系统资源，它使⽤户能够访问任何可以通过 URL、Path、系统⽂件路径表⽰的资源，如⽂件系统的资源、HTTP 资源、FTP 资源等。</li>
</ul>
<p>有了这个抽象的资源类后，就可以将 Spring 的配置信息放置在任何地⽅（如数据库、LDAP 中），只要最终可以通过 Resource 接口返回配置信息即可。</p>
<p>假设有⼀个⽂件位于 Web 应⽤的类路径下，⽤户可以通过以下⽅式对这个⽂件资源进⾏访问：</p>
<ul>
<li>通过 FileSystemResource 以⽂件系统绝对路径的⽅式进⾏访问。</li>
<li>通过 ClassPathResource 以类路径的⽅式进⾏访问。</li>
<li>通过 ServletContextResource 以相对于 Web 应⽤根⽬录的⽅式进⾏访问。</li>
</ul>
<p>相⽐于通过JDK 的File 类访问⽂件资源的⽅式，Spring 的Resource 实现类⽆疑提<br>供了更加灵活便捷的访问⽅式，⽤户可以根据实际情况选择适合的 Resource 实现类访<br>问资源。以上代码就是分别通过 FileSystemResource 和 ClassPathResource 访问同⼀个⽂件资源，</p>
<p>在获取资源后，⽤户就可以通过Resource 接⼝定义的多个⽅法访问⽂件的数据和其<br>他信息。如可以通过 getFileName（）⽅法获取⽂件名，通过 getFile（）⽅法获取资源对应的<br>File 对象，通过 getinputStream（⽅法直接获取⽂件的输⼊流。通过 WritableResource 接<br>口定义的多个⽅法向⽂件写数据，通过 getOutputStream（）⽅法直接获取⽂件的输出流。此外，还可以通过 createRelative（String relativePath）在资源相对地址上创建新的⽂件。</p>
<p>在 Web 应⽤中，⽤户还可以通过 ServletContextResource 以相对于 Web 应⽤根⽬录<br>的⽅式访问⽂件资源，如代码：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.web.context.support.ServletContextResource&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.core.io.Resource&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.web.util.WebUtils&quot;</span>/&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">//获取ServletContext对象:文件地址相对于Web应用根目录</span></span><br><span class="line">   <span class="type">Resource</span> <span class="variable">res3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(application,<span class="string">&quot;/WEB-INF/classes/conf/file1.txt&quot;</span>);</span><br><span class="line">   out.print(res3.getFilename()+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">   out.print(WebUtils.getTempDir(application).getAbsolutePath());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>对于位于远程服务器（Web 服务器或FTP服务器）的⽂件资源，⽤户可以⽅便地通<br>过 UriResource 进⾏访问。资源加载时默认采⽤系统编码读取资源内容。如果资源⽂件采⽤特殊的编码格式，那么可以通过 EncodedResource 对资源进⾏编码，以保证资源内容操作的正确性，如代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.EncodedResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.FileCopyUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodedResourceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable  &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;conf/file1.txt&quot;</span>);</span><br><span class="line">    <span class="type">EncodedResource</span> <span class="variable">encRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncodedResource</span>(res,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span>  <span class="operator">=</span> FileCopyUtils.copyToString(encRes.getReader());</span><br><span class="line">    System.out.println(content);  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>为了访问不同类型的资源，必须使⽤相应的 Resource 实现类，这是⽐较麻烦的。是否可以在不显式使⽤ Resource 实现类的情况下，仅通过资源地址的特殊标识就可以访问相应的资源呢？Spring 提供了⼀个强⼤的加载资源的机制，不但能够通过“classpath：”、 “file：” 等资源地址前缀识别不同的资源类型，还⽀持 Ant 风格带通配符的资源地址。</p>
<ol>
<li>资源地址表达式</li>
</ol>
<p>⾸先来了解⼀下 Spring ⽀持哪些资源类型的地址前缀，如表：</p>
<table>
<thead>
<tr>
<th>地址前缀</th>
<th>示例</th>
<th>对应的资源类型</th>
</tr>
</thead>
<tbody><tr>
<td>classpath</td>
<td>classpath:com&#x2F;smart&#x2F;beanfactory&#x2F;beans.xml</td>
<td>从类路径中加载资源，classpath:和classpath:&#x2F;&#x2F;是等价的，都是相对于类的根路径。资源文件可以在标准的文件系统重，也可以在JAR或ZIP的类包中</td>
</tr>
<tr>
<td>file:</td>
<td>file:&#x2F;conf&#x2F;com&#x2F;smart&#x2F;beanfactory&#x2F;beans.xml</td>
<td>使⽤ UriResource 从⽂件系统⽬录中装载资源，可采⽤绝对或相对路径</td>
</tr>
<tr>
<td>http:</td>
<td><a target="_blank" rel="noopener" href="http://www.javass.cn/beans.xml">http://www.javass.cn/beans.xml</a></td>
<td>使⽤ UriResource 从 Web 服务器中装载资源</td>
</tr>
<tr>
<td>ftp:</td>
<td><a href="ftp://ftp.javass.cn/beans.xml">ftp://ftp.javass.cn/beans.xml</a></td>
<td>使⽤ UriResource 从 FTP 服务器中装载资源</td>
</tr>
<tr>
<td>没有前缀</td>
<td>&#x2F;com&#x2F;smart&#x2F;beanfactory&#x2F;beans.xml</td>
<td>根据ApplicationContext的具体实现类型采用对应的Resource</td>
</tr>
</tbody></table>
<p>其中，和“classpath：”对应的还有另⼀种⽐较难理解的“classpath<em>：”前缀。假设有多个JAR 包或⽂件系统类路径都拥有⼀个相同的包名（如 com.smart）。“classpath：” 只会在第⼀个加载的com.smart 包的类路径下查找，⽽“classpath</em>：”会扫描所有这些JAR 包及类路径下出现的 com.smart类路径。 这对于分模块打包的应⽤⾮常有⽤。假设⼀个名为 smart 的应⽤共分成3个模块， ⼀个模块对应⼀个配置⽂件，分别是 modulel.xml、module2.xml 及 module4.xml，都放 到com.smart ⽬录下，每个模块单独打成JAR包。使⽤ <em>“classpath<em>：com&#x2F;smart&#x2F;module</em>.xml”</em> 可以成功加载这3个模块的配置⽂件，⽽使⽤ <em>“classpath:com&#x2F;smart&#x2F;module*.xml”</em> 只会加载⼀个模块的配置⽂件。</p>
<p>Ant风格的资源地址⽀持3种匹配符。</p>
<ul>
<li>？：匹配⽂件名中的⼀个字符。</li>
<li>*：匹配⽂件名中的任意字符。</li>
<li>**：匹配多层路径。</li>
</ul>
<p>下⾯是⼏个 Ant 风格的资源路径的⽰例。</p>
<ul>
<li>classpath:com&#x2F;t?st.xml： 匹配 com类路径下的 com&#x2F;test.xml、com&#x2F;tast.xml 或者com&#x2F;txst.xml ⽂件。</li>
<li>file:D:&#x2F;conf&#x2F;*.xml：匹配⽂件系统 D:&#x2F;conf ⽬录下所有以.xml为后缀的⽂件。</li>
<li>classpath:com&#x2F;**&#x2F;test.xml：匹配com类路径下（当前⽬录及其⼦孙⽬录）的 test.xml⽂件。</li>
<li>classpath:org&#x2F;springframework&#x2F;**&#x2F;*、xml：匹配类路径 org&#x2F;springframework 下所有 以.xml 为后缀的⽂件。</li>
<li>classpath:org&#x2F;**&#x2F;servlet&#x2F;bla.xml： 不仅匹配类路径 org&#x2F;springframework&#x2F;servlet&#x2F;bla. xml，也匹配 org&#x2F;springframework&#x2F;testing&#x2F;servlet&#x2F;bla.xml，还匹配 org&#x2F;servlet&#x2F;bla.xml。</li>
</ul>
<ol>
<li>资源加载器<br>Spring 定义了⼀套资源加载的接口，并提供了实现类：</li>
</ol>
<pre class="mermaid">


classDiagram
direction TB
class ResourceLoader {
&lt;&lt;Interface&gt;&gt;

+ getResource(String) Resource
}
class ResourcePatternResolver {
&lt;&lt;Interface&gt;&gt;
+ getResources(String) Resource[]
}
class PathMatchingResourcePatternResolver
class Resouce{
&lt;&lt;Interface&gt;&gt;
+ getFile() : File
+ getURI() : URI
}
ResourceLoader --&gt; Resouce
ResourceLoader &lt;|-- ResourcePatternResolver
ResourcePatternResolver &lt;|.. PathMatchingResourcePatternResolver

</pre>

<p>ResourceLoader 接⼝仅有⼀个 getResource（String location）⽅法，可以根据⼀个资源<br>地址加载⽂件资源。不过，资源地址仅⽀持带资源类型前缀的表达式，不⽀持Ant⻛格的资源路径表达式。ResourcePatterResolver 扩展 ResourceLoader 接⼝，定义了⼀个新的接⼝⽅法 getResources（String locationPattern），该⽅法⽀持带资源类型前缀及Ant⻛格的资源路径表达式。PathMatchingResourcePatterResolver 是 Spring 提供的标准实现类，<br>来看⼀个例⼦，如代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.testng.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternResolverTest</span>｛</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResources</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        <span class="comment">//加载所有类路径下的以xml为后缀的文件</span></span><br><span class="line">        Resource[] resources = resolver.getResources(<span class="string">&quot;classpath*:com/smart/**/*.xml&quot;</span>);</span><br><span class="line">        assertNotNull(resources);</span><br><span class="line">        <span class="keyword">for</span>(Resource resource:resources)&#123;</span><br><span class="line">            System.out.println(resource.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于资源路径是“classpath*：”，所以 PathMatchingResourcePatternResolver 将扫描所有类路径下及JAR 包中对应 com.smart类包下的路径，读取所有以.xml 后缀的⽂件资源。</p>
<p><span style="color:orange">注意：</span></p>
<p>⽤ Resource 操作⽂件时，如果资源配置⽂件在项⽬发布时会被打包到JAR 中，那么不能使⽤ Resource#getFile（）⽅法，否则会抛出 FileNotFoundException。但可以使⽤<br>Resource#getlnputStream()⽅法读取。</p>
<p>错误的读取⽅式：</p>
<p><code>（new DefaultResourceloader（））.getResource（&quot;classpath:conf/sys.properties&quot;）. getFile（）</code></p>
<p>正确的读取⽅式：</p>
<p><code>（new DefaultResourceloader（））.getResource（&quot;classpath:conf/sys.properties&quot;）. getInputStream（）</code></p>
<p>这个问题在实际的项⽬开发过程中很容易被忽视，因为在项⽬开发时，资源配置⽂ 件⼀般是在⽂件夹下的，所以 Resource#getFile（是可以正常⼯作的。但在发布时，如果 资源配置⽂件被打包到JAR 中，这时 getFile（就⽆法读取了，从⽽造成部署实施的时候 出现意想不到的问题。因此，我们建议尽量以流的⽅式读取，避免环境不同造成的问题。</p>
<h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><p>Spring 通过⼀个配置⽂件描述 Bean 及 Bean 之间的依赖关系，利⽤Java 语⾔的反 射功能实例化 Bean 并建⽴ Bean 之间的依赖关系。Spring 的IoC 容器在完成这些底层⼯ 作的基础上，还提供了 Bean 实例缓存、⽣命周期管理、Bean 实例代理、事件发布、资源装载等⾼级服务。</p>
<p>Bean ⼯⼚ （com.springframe work.beans.factory.BeanFactory） 是Spring 框架最核⼼的 接口，它提供了⾼级 IoC 的配置机制。BeanFactory 使管理不同类型的 Java 对象成为可 能，应⽤上下⽂ （com.springframework.context.ApplicationContext） 建⽴在 BeanFactory 基础之上，提供了更多⾯向应⽤的功能，它提供了国际化⽀持和框架事件体系，更易于 创建实际应⽤。我们⼀般称 BeanFactory 为 IoC 容器，⽽称 ApplicationContext 为应⽤上 下⽂。但有时为了⾏⽂⽅便，我们也将 ApplicationContext 称为 Spring 容器。</p>
<p>对于⼆者的⽤途，我们可以进⾏简单的划分：BeanFactory 是 Spring 框架的基础设施，⾯向 Spring 本⾝；ApplicationContext ⾯向使⽤ Spring 框架的开发者，⼏乎所有的应⽤场合都可以直接使⽤ ApplicationContext ⽽⾮底层的 BeanFactory。</p>
<h3 id="BeanFactory介绍"><a href="#BeanFactory介绍" class="headerlink" title="BeanFactory介绍"></a>BeanFactory介绍</h3><p>诚如其名，BeanFactory是⼀个类⼯⼚，但和传统的类⼯⼚不同，传统的类⼯⼚仅负责构造⼀个或⼏个类的实例；⽽ BeanFactory 是类的通⽤⼯⼚，它可以创建并管理各种类的对象。这些可被创建和管理的对象本⾝没有什么特别之处，仅是⼀个POJO,Spring称这些被创建和管理的Java 对象 Bean。我们知道JavaBean 是要满⾜⼀定规范的，如：</p>
<ul>
<li>必须提供⼀个默认不带参的构造函数、</li>
<li>不依赖于某⼀特定的容器等，</li>
</ul>
<p>但Spring 中所说的Bean ⽐ JavaBean更宽泛⼀些，所有可以被 Spring 容器实例化并管理的Java 类都可以成为Bean。</p>
<h4 id="BeanFactory-的类体系结构"><a href="#BeanFactory-的类体系结构" class="headerlink" title="BeanFactory 的类体系结构"></a>BeanFactory 的类体系结构</h4><p>Spring 为 BeanFactory 提供了多种实现，最常⽤的是 XmlBeanFactory，但在 Spring 3.2中已被废弃，建议使⽤ XmlBeanDeﬁnitionReader、DefaultListableBeanFactory 替代。BeanFactory 的类继承体系设计优雅，堪称经典。通过继承体系，我们可以很容易地了解到 BeanFactory 具有哪些功能，如图:</p>
<pre class="mermaid">

classDiagram
direction BT
class AbstractAutowireCapableBeanFactory
class AbstractBeanFactory
class AutowireCapableBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class BeanDefinitionRegistry {
&lt;&lt;Interface&gt;&gt;

}
class BeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class ConfigurableBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class ConfigurableListableBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class DefaultListableBeanFactory
class DefaultSingletonBeanRegistry
class HierarchicalBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class ListableBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class SingletonBeanRegistry {
&lt;&lt;Interface&gt;&gt;

}
class XmlBeanFactory

AbstractAutowireCapableBeanFactory  --&gt;  AbstractBeanFactory
AbstractAutowireCapableBeanFactory  ..&gt;  AutowireCapableBeanFactory
AbstractBeanFactory &quot;1&quot; *--&gt; &quot;parentBeanFactory 1&quot; BeanFactory
AbstractBeanFactory  --&gt;  DefaultSingletonBeanRegistry
ConfigurableBeanFactory  --&gt;  HierarchicalBeanFactory
ConfigurableListableBeanFactory  --&gt;  ConfigurableBeanFactory
ConfigurableListableBeanFactory  --&gt;  ListableBeanFactory
DefaultListableBeanFactory  --&gt;  AbstractAutowireCapableBeanFactory
DefaultListableBeanFactory  ..&gt;  BeanDefinitionRegistry
DefaultListableBeanFactory  ..&gt;  ConfigurableListableBeanFactory
DefaultSingletonBeanRegistry  ..&gt;  SingletonBeanRegistry
HierarchicalBeanFactory  --&gt;  BeanFactory
ListableBeanFactory  --&gt;  BeanFactory
XmlBeanFactory  --&gt;  DefaultListableBeanFactory
</pre>

<p>BeanFactory 接口位于类结构树的顶端，它最主要的⽅法就是 getBean（StringbeanName），该⽅法从容器中返回特定名称的 Bean。BeanFactory 的功能通过其他接口得到不断扩展。下⾯对图中涉及的其他接口分别进⾏说明。</p>
<ul>
<li>ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若⼲⽅法，如查看 Bean 的个数、获取某⼀类型 Bean的配置名、查看容器中是否包括某⼀Bean 等。</li>
<li>HierarchicalBeanFactory：⽗⼦级联IoC 容器的接口，⼦容器可以通过接口⽅法访问⽗容器。</li>
<li>ConfigurableBeanFactory：这是⼀个重要的接口，增强了IoC 容器的可定制性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等⽅法。</li>
<li>AutowireCapableBeanFactory： 定义了将容器中的 Bean按某种规则（如按名字匹配、按类型匹配等）进⾏⾃动装配的⽅法。</li>
<li>SingletonBeanRegistry：定义了允许在运⾏期向容器注册单实例Bean的⽅法。</li>
<li>BeanDefinitionRegistry: Spring 配置⽂件中每⼀个<code>&lt;bean&gt;</code>节点元素在Spring 容器⾥都通过⼀个 BeanDefinition 对象表⽰，它描述了 Bean 的配置信息。⽽BeanDefinition Registry 接口提供了向容器⼿⼯注册 BeanDefinition 对象的⽅法。</li>
</ul>
<h4 id="初始化BeanFactory"><a href="#初始化BeanFactory" class="headerlink" title="初始化BeanFactory"></a>初始化BeanFactory</h4><p>下⾯使⽤Spring 配置⽂件为 Car 提供配置信息，然后通过 BeanFactory 装载配置⽂件，启动 Spring IoC 容器。Spring 配置⽂件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;？xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;？&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w4.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;beanid=&quot;car1&quot; class=&quot;com.smart.Car&quot;</span><br><span class="line"></span><br><span class="line">p:brand=&quot;红旗CA72&quot; p:coloz=&quot;⿊⾊&quot;</span><br><span class="line"></span><br><span class="line">PimaxSpeed=&quot;200&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下⾯通过 XmlBeanDefinitionReader、DefaultListableBeanFactory 实现类启动 SpringIoC 容器，如代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.beanfactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader; </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver; <span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.testng.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryTest</span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> getBean（） <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> resolver.getResource （<span class="string">&quot;classpath: com/smart/beanfactory/beans.</span></span><br><span class="line"><span class="string">xml&quot;</span>）;</span><br><span class="line">System.out.println(res.getURL());</span><br><span class="line"><span class="comment">//被废弃，不建议使⽤</span></span><br><span class="line"><span class="comment">//BeanFactory bf - new XmlBeanFactory （res）：</span></span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory factory= <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory)：</span><br><span class="line"></span><br><span class="line">reader. loadBeanDefinitions(res)；</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;init BeanFactory.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> factory.getBean(<span class="string">&quot;car&quot;</span>，Car.class);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;car bean is ready for use！&quot;</span>)；</span><br><span class="line"></span><br><span class="line">car.introduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XmlBeanDefinitionReader 通过 Resource 装载 Spring 配置信息并启动IOC 容器，然后就可以通过 BeanFactory#getBean（beanName）⽅法从 IoC 容器中获取 Bean。通过BeanFactory 启动IoC 容器时，并不会初始化配置⽂件中定义的Bean，初始化动作发⽣在第⼀个调⽤时。对于单实例（singleton）的Bean 来说，BeanFactory 会缓存Bean实例，所以第⼆次使⽤ getBean（）获取 Bean 时，将直接从IoC容器的缓存中获取 Bean实例。</p>
<p>Spring 在 DefaultSingletonBeanRegistry 类中提供了⼀个⽤于缓存单实例Bean的缓存器，它是⼀个⽤ HashMap 实现的缓存器，单实例的 Bean以 beanName 为键保存在这个HashMap 中。</p>
<p>值得⼀提的是，在初始化 BeanFactory 时，必须为其提供⼀种⽇志框架，我们使⽤Log4J，即在类路径下提供Log4J配置⽂件，这样启动 Spring 容器才不会报错。</p>
<h3 id="ApplicationContext介绍"><a href="#ApplicationContext介绍" class="headerlink" title="ApplicationContext介绍"></a>ApplicationContext介绍</h3><p>如果说 BeanFactory 是Spring 的“⼼脏”，那么 ApplicationContext 就是完整的“身躯”了。ApplicationContext 由BeanFactory 派⽣⽽来，提供了更多⾯向实际应⽤的功能。在 BeanFactory 中，很多功能需要以编程的⽅式实现，⽽在 ApplicationContext 中则可以通过配置的⽅式实现。</p>
<h4 id="ApplicationContext的类体系结构"><a href="#ApplicationContext的类体系结构" class="headerlink" title="ApplicationContext的类体系结构"></a>ApplicationContext的类体系结构</h4><p>ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置⽂件，后者默认从⽂件系统中装载配置⽂件。下⾯了解⼀下 ApplicationContext 的类继承体系，如图：</p>
<pre class="mermaid">

classDiagram
direction BT
class AbstractApplicationContext
class AbstractRefreshableApplicationContext
class AbstractRefreshableConfigApplicationContext
class AbstractXmlApplicationContext
class AnnotationConfigApplicationContext
class ApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class ApplicationEventPublisher {
&lt;&lt;Interface&gt;&gt;

}
class BeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class ClassPathXmlApplicationContext
class ConfigurableApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class FileSystemXmlApplicationContext
class GenericApplicationContext
class GenericGroovyApplicationContext
class HierarchicalBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class Lifecycle {
&lt;&lt;Interface&gt;&gt;

}
class ListableBeanFactory {
&lt;&lt;Interface&gt;&gt;

}
class MessageSource {
&lt;&lt;Interface&gt;&gt;

}
class ResourceLoader {
&lt;&lt;Interface&gt;&gt;

}
class ResourcePatternResolver {
&lt;&lt;Interface&gt;&gt;

}

AbstractApplicationContext  ..&gt;  ConfigurableApplicationContext 
AbstractApplicationContext  ..&gt;  ResourceLoader 
AbstractRefreshableApplicationContext  --&gt;  AbstractApplicationContext 
AbstractRefreshableConfigApplicationContext  --&gt;  AbstractRefreshableApplicationContext 
AbstractXmlApplicationContext  --&gt;  AbstractRefreshableConfigApplicationContext 
AnnotationConfigApplicationContext  --&gt;  GenericApplicationContext 
ApplicationContext  --&gt;  ApplicationEventPublisher 
ApplicationContext  --&gt;  HierarchicalBeanFactory 
ApplicationContext  --&gt;  ListableBeanFactory 
ApplicationContext  --&gt;  MessageSource 
ApplicationContext  --&gt;  ResourcePatternResolver 
ClassPathXmlApplicationContext  --&gt;  AbstractXmlApplicationContext 
ConfigurableApplicationContext  --&gt;  ApplicationContext 
ConfigurableApplicationContext  --&gt;  Lifecycle 
FileSystemXmlApplicationContext  --&gt;  AbstractXmlApplicationContext 
GenericApplicationContext  --&gt;  AbstractApplicationContext 
GenericGroovyApplicationContext  --&gt;  GenericApplicationContext 
HierarchicalBeanFactory  --&gt;  BeanFactory 
ListableBeanFactory  --&gt;  BeanFactory 
ResourcePatternResolver  --&gt;  ResourceLoader
</pre>

<p>从图中可以看出，ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功<br>能。这些接⼝如下。</p>
<ul>
<li>ApplicationEventPublisher： 让容器拥有发布应⽤上下⽂事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进⾏响应处理。在 ApplicationContext 抽象实现类 AbstractApplicationContext 中存在⼀个 ApplicationEventMulticaster，它负责保存所有的监听器，以便在容器产⽣上下⽂事件时通知这些事件监听者。</li>
<li>MessageSource：为应⽤提供il8n 国际化消息访问的功能。</li>
<li>ResourcePatterResolver： 所有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源⽂件路径装载 Spring 的配置⽂件。</li>
<li>LifeCycle：该接口提供了 start()和stop()两个⽅法，主要⽤于控制异步处理过程。在具体使⽤时，该接口同时被 ApplicationContext 实现及具体 Bean实现， ApplicationContext 会将 start&#x2F;stop 的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等⽬的。</li>
</ul>
<p>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增了两个主要的⽅法：refresh（）和 close（），让 ApplicationContext 具有启动、刷新和关闭应⽤上下⽂的能⼒。在应⽤上下⽂关闭的情况下调⽤ refresh()即可启动应⽤上下⽂，在已经启动的状态下调⽤ refresh()则可清除缓存并重新装载配置信息，⽽调⽤close()则可关闭应⽤上下⽂。这些接口⽅法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关⼼这些⽅法。</p>
<p>和 BeanFactory 初始化相似，ApplicationContext 的初始化也很简单。如果配置⽂件放置在类路径下，则可以优先考虑使⽤ClassPathXmlApplicationContext 实现类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line"></span><br><span class="line">new ClassPathXmlApplicationContext （&quot;com/smart/context/beans .xm1&quot;）；</span><br></pre></td></tr></table></figure>

<p>对于 ClassPathXmlApplicationContext 来说，“com&#x2F;smart&#x2F;context&#x2F;beans.xml” 等同于“classpath: com&#x2F;smart&#x2F;context&#x2F;beans.xml”。</p>
<p>还可以指定⼀组配置⽂件，Spring 会⾃动将多个配置⽂件在内存中“整合”成⼀个<br>配置⽂件，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext（</span><br><span class="line"></span><br><span class="line">new String［］！&quot;conf/beans1.xml&quot;，&quot;conf/beans2.xml&quot;））；</span><br></pre></td></tr></table></figure>

<p>当然，FileSystemXmlApplicationContext 和 ClassPathXmlApplicationContext 都可以显式使⽤带资源类型前缀的路径，它们的区别在于如果不显式指定资源类型前缀，则分别将路径解析为⽂件系统路径和类路径。</p>
<p>在获取 ApplicationContext 实例后，就可以像 BeanFactory⼀样调⽤ getBean（beanName）返回Bean 了。ApplicationContext 的初始化和 BeanFactory 有⼀个重⼤的区别：</p>
<ul>
<li>BeanFactory在初始化容器时，并未实例化 Bean，直到第⼀次访问某个 Bean 时才实例化⽬标 Bean；</li>
<li>⽽ ApplicationContext 则在初始化应⽤上下⽂时就实例化所有单实例的 Bean。</li>
</ul>
<p>因此，ApplicationContext 的初始化时间会⽐ BeanFactory 稍长⼀些，不过稍后的调⽤则没有“第⼀次惩罚”的问题。</p>
<p>Spring ⽀持基于类注解的配置⽅式，主要功能来⾃ Spring的⼀个名为 JavaConfig 的⼦项⽬。JavaConfig 现已升级为 Spring 核⼼框架的⼀部分。⼀个标注@Configuration 注解的 POJO 即可提供 Spring 所需的Bean配置信息，如代码所⽰:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//①表示是一个配置信息提供类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beans</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//②定义了一个Bean</span></span><br><span class="line"> <span class="meta">@Bean(name = &quot;car&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> Car <span class="title function_">buildCar</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">  car.setBrand(<span class="string">&quot;红旗CA72&quot;</span>);</span><br><span class="line">  car.setMaxSpeed(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">return</span> car;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和基于 XML ⽂件的配置⽅式相⽐，类注解的配置⽅式可以很容易地让开发者控制Bean 的初始化过程，⽐基于XML ⽂件的配置⽅式更加灵活。</p>
<p>Spring 为基于注解类的配置提供了专门的 ApplicationContext 实现类：<br>AnnotationConfigApplicationContext。来看⼀个使⽤AnnotationConfigApplicationContext<br>启动 Spring 容器的⽰例，如代码所⽰:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.context;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.smart.Car;<span class="keyword">import</span> <span class="keyword">static</span> org.testng.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContextTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> getBean（）&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//①通过⼀个带@Configuration的POJO装载Bean配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Beans.class);</span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span>ctx.getBean （<span class="string">&quot;car&quot;</span>， Car.class）；</span><br><span class="line">assertNotNul1(car);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Annotation ConfigApplicationContext 将加载 Beans.class 中的 Bean 定义并调⽤<br>Beans.class 中的⽅法实例化 Bean，启动容器并装配 Bean。关于使⽤ JavaConfig 配置⽅<br>式的详细内容，将在第5章详细介绍。</p>
<p>Spring 4.0 ⽀持使⽤ <a target="_blank" rel="noopener" href="https://groovy-lang.org/documentation.html">Groovy DSL</a> 来进⾏Bean定义配置。其与基于XML ⽂件的配<br>置类似，只不过基于 Groovy 脚本语⾔，可以实现复杂、灵活的 Bean 配置逻辑，来看⼀<br>个例⼦，如代码:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.context;</span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line">beans&#123;</span><br><span class="line">    car（Car）&#123;<span class="comment">//①名字（类型）</span></span><br><span class="line">    brand =<span class="string">&quot;红旗CA72&quot;</span> <span class="comment">//②注⼊属性</span></span><br><span class="line">    maxSpeed = <span class="string">&quot;200&quot;</span></span><br><span class="line">    color = <span class="string">&quot;red&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 Groovy的配置⽅式可以很容易地让开发者配置复杂Bean 的初始化过程，⽐基于 XML ⽂件、注解的配置⽅式更加灵活。Spring 为基于 Groovy 的配置提供了专⻔的 ApplicationContext 实现类：<br>GenericGroovyApplicationContext。来看⼀个如何使⽤ GenericGroovyApplicationContext启动 Spring 容器的⽰例，如代码清单所⽰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.context;</span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.GenericGroovyApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.testng.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroovyApplicationContextTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getBean</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">GenericGroovyApplicationContext</span> (<span class="string">&quot;classpath:com/smart/context/groovy-beans.groovy&quot;</span>);</span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) ctx.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">assertNotNull(car);</span><br><span class="line">assertEquals(car.getColor()， <span class="string">&quot;red&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WebApplicationContext-类体系结构"><a href="#WebApplicationContext-类体系结构" class="headerlink" title="WebApplicationContext 类体系结构"></a>WebApplicationContext 类体系结构</h4><p>WebApplicationContext 是专门为 Web 应⽤准备的，它允许从相对于 Web 根⽬录的<br>路径中装载配置⽂件完成初始化⼯作。从 WebApplicationContext 中可以获得 ServletContext的引⽤，整个 Web 应⽤上下⽂对象将作为属性放置到 ServletContext 中，以便 Web 应⽤环境可以访问 Spring 应⽤上下⽂。Spring 专门为此提供了⼀个⼯具类 WebApplicationContextUtils，通过该类的 getWebApplicationContext(ServletContext sc)⽅法，可以从ServletContext 中荻取 WebApplicationContext 实例。</p>
<p>在⾮ Web 应⽤的环境下，Bean 只有 singleton 和 prototype 两种作⽤域。<br>WebApplicationContext 为 Bean 添加了三个新的作⽤域：request、 session 和 global session。</p>
<p>下⾯来看⼀下 WebApplicationContext 的类继承体系，如图：</p>
<pre class="mermaid">

classDiagram
direction BT
class AbstractApplicationContext
class AbstractRefreshableApplicationContext
class AbstractRefreshableConfigApplicationContext
class AbstractRefreshableWebApplicationContext
class AbstractXmlApplicationContext
class AnnotationConfigWebApplicationContext
class ApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class ConfigurableApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class ConfigurableWebApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class GroovyWebApplicationContext
class WebApplicationContext {
&lt;&lt;Interface&gt;&gt;

}
class XmlWebApplicationContext

AbstractApplicationContext  ..&gt;  ConfigurableApplicationContext 
AbstractRefreshableApplicationContext  --&gt;  AbstractApplicationContext 
AbstractRefreshableConfigApplicationContext  --&gt;  AbstractRefreshableApplicationContext 
AbstractRefreshableWebApplicationContext  --&gt;  AbstractRefreshableConfigApplicationContext 
AbstractRefreshableWebApplicationContext  ..&gt;  ConfigurableWebApplicationContext 
AbstractXmlApplicationContext  --&gt;  AbstractRefreshableConfigApplicationContext 
AnnotationConfigWebApplicationContext  --&gt;  AbstractRefreshableWebApplicationContext 
ConfigurableApplicationContext  --&gt;  ApplicationContext 
ConfigurableWebApplicationContext  --&gt;  ConfigurableApplicationContext 
ConfigurableWebApplicationContext  --&gt;  WebApplicationContext 
GroovyWebApplicationContext  --&gt;  AbstractRefreshableWebApplicationContext 
WebApplicationContext  --&gt;  ApplicationContext 
XmlWebApplicationContext  --&gt;  AbstractRefreshableWebApplicationContext 
</pre>

<p>由于 Web 应⽤⽐⼀般的应⽤拥有更多的特性，因此 WebApplicationContext 扩展了ApplicationContext。WebApplicationContext 定义了⼀个常量 ROOT_WEB_APPLICATION_<br>CONTEXT_ATTRIBUTE，在上下⽂启动时，WebApplicationContext 实例即以此为键放<br>置在 ServletContext的属性列表中，可以通过以下语句从 Web 容器中获取 WebApplication<br>Context：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> （WebApplicationContext） servletContext.getAttribute （ WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE）;</span><br></pre></td></tr></table></figure>

<p>这正是前⾯提到的 WebApplicationContextUtils ⼯具类 get WebApplicationContext<br>（ServletContext sc）⽅法的内部实现⽅式。这样，Spring 的 Web 应⽤上下⽂和 Web 容器的<br>上下⽂应⽤就可以实现互访，⼆者实现了融合，如图：</p>
<p><img src="/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/Spring%E5%92%8Cweb%E5%BA%94%E2%BD%A4%E7%9A%84%E4%B8%8A%E4%B8%8B%E2%BD%82%E8%9E%8D%E5%90%88.png" alt="Spring和web应⽤的上下⽂融合"></p>
<p>ConfigurableWebApplicationContext 扩展了 WebApplicationContext，它允许通过配置的⽅式实例化 WebApplicationContext，同时定义了两个重要的⽅法。</p>
<ul>
<li>setServletContext（ServletContext servletContext）：为Spring设置 Web 应用上下文以便⼆者整合。</li>
<li>etConfigLocations（String[]configLocations）：设置 Spring 配置⽂件地址，⼀般<br>况下，配置⽂件地址是相对于 Web 根⽬录的地址，如&#x2F;WEB-INF&#x2F;smart-dao.xml、&#x2F;WEB-INF&#x2F;smart-service.xml 等。但⽤户也可以使⽤带资源类型前缀的地址，如<br>classpath:com&#x2F;smart&#x2F;beans.xml 等。</li>
</ul>
<h4 id="WebApplicationContext-初始化"><a href="#WebApplicationContext-初始化" class="headerlink" title="WebApplicationContext 初始化"></a>WebApplicationContext 初始化</h4><p>WebApplicationContext 的初始化⽅式和 BeanFactory、ApplicationContext 有所区别，<br>因为 WebApplicationContext 需要 ServletContext实例，也就是说，它必须在拥有Web容<br>器的前提下才能完成启动⼯作。有过Web 开发经验的读者都知道，可以在web.xml 中配置⾃启动的 Servlet 或定义 Web 容器监听器（ServletContextListener），借助⼆者中的任<br>何⼀个，就可以完成启动 Spring Web 应⽤上下⽂的⼯作。</p>
<span style="color:cadetBlue">
所有版本的Web 容器都可以定义⾃启动的 Servlet，但只有 Servlet 2.3及以上版本
的 Web 容器才⽀持 Web 容器监听器。有些即使⽀持 Servlet 2.3的Web服务器，也
不能在 Servlet 初始化之前启动Web 监听器，如Weblogic 8.1、Web Sphere 5.x、Oracle
0C4J 9.0。
</span>

<p>Spring 分别提供了⽤于启动WebApplicationContext 的 Servlet 和Web 容器监听器：</p>
<ul>
<li>org.springframework.web.context.ContextLoaderServlet。</li>
<li>org-springframework.web.context.ContextLoaderListener。</li>
</ul>
<p>⼆者的内部都实现了启动 WebApplicationContext 实例的逻辑，只要根据 Web 容器<br>的具体情况选择⼆者之⼀，并在 web.xml 中完成配置即可。</p>
<p>如下代码清单使⽤ ContextLoaderListener 启动 WebApplicationContext 的具体<br>配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="comment">&lt;!--①指定配置⽂件 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">         /WEB-INE/smart-dao.xml,/WEB-INF/smart-service.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--②声明web容器监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.context. ContextloaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ContextLoaderListener 通过 Web 容器上下⽂参数 contextConfigLocation 获取 Spring配置⽂件的位置。⽤户可以指定多个配置⽂件，⽤逗号、空格或冒号分隔均可。对于未带资源类型前缀的配置⽂件路径，WebApplicationContext 默认这些路径相对于 Web 的部署根路径。当然，也可以采⽤带资源类型前缀的路径配置，如“classpath<em>：&#x2F;smart-</em>.xml”和上⾯的配置是等效的。</p>
<p>如果在不⽀持容器监听器的低版本 Web 容器中，则可以采⽤ ContextLoaderServlet<br>完成相同的⼯作，如代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">    /WEB-INF/smart-dao.xml,/WEB-INF/smart-service.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--①声明⽩启动的Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframevork,web.context.ContextLoaderServlet <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--②启动顺序--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1&lt;/1oad-on-startup&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于 WebApplicationContext 需要使⽤⽇志功能，所以⽤户可以将Log4J的配置⽂件放置在类路径 WEB-INF&#x2F;classes 下，这时Log4J 引擎即可顺利启动。如果Log4J 配置⽂件放置在其他位置，那么⽤户必须在web.xml 中指定Log4J配置⽂件的位置。Spring为启动Log4J引擎提供了两个类似于启动 WebApplicationContext 的实现类：Log4jConfigServlet和 Log4jConfigListener， 不管采⽤哪种⽅式，都必须保证能够在装载 Spring 配置⽂件前<br>先装载Log4J配置信息，如代码:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfiglocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> </span><br><span class="line">        /WEB-INE/smart-dao.xml,/WEB-INE/smart-service.xml </span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--①指定Log4J配置⽂件的位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>1og4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/1og4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--②裝载Log4J配置⽂件的⾃启动Servlet--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>1og4jConfigServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframevork.web.util.Log4jConfigServlet<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1&lt;/1oad-on-startup&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> springContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-Class</span>&gt;</span>org.springframework.web.context.ContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-Class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意上⾯将 log4jConfigServlet 的启动顺序号设置为1，⽽将 springContextLoaderServlet的启动顺序号设置为2。这样，前者将先启动，完成装载Log4J配置⽂件并初始化Log4J引擎的⼯作，紧接着后者再启动。如果使⽤ Web 监听器，则必须将 Log4jConfigListener放置在 ContextLoaderListener 的前⾯。采⽤以上配置⽅式，Spring 将⾃动使⽤Xml WebApplicationContext 启动 Spring 容器，即通过 XML ⽂件为 Spring 容器提供 Bean的配置信息。</p>
<p>如果使⽤标注@Configuration 的Java 类提供配置信息，则web.xml 需要按以下⽅式配置，如代码:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过指定context参数，让Spring使用GroovyWebApplicationContext而非</span></span><br><span class="line"><span class="comment">    XmlWebApplicationContext或AnnotationConfigWebApplicationContext启动容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.GroovyWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定标注了Groovy的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            classpath:conf/spring-mvc.groovy</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ContextLoaderListener监听器将根据上面配置使用</span></span><br><span class="line"><span class="comment">         AnnotationConfigWebApplicationContext根据contextConfigLocation</span></span><br><span class="line"><span class="comment">         指定的配置类启动Spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>GroovyWebApplicationContext 实现类会根据 contextConfigLocation 上下⽂参数指定<br>的 conf&#x2F;spring-mvc.groovy 所提供的 Spring 配置信息初始化容器。如spring-mvc.groovy:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.validator.HibernateValidator</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.i18n.CookieLocaleResolver</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.i18n.LocaleChangeInterceptor</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">beans &#123;</span><br><span class="line">    xmlns <span class="attr">context:</span> <span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">    xmlns <span class="attr">mvc:</span> <span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="line"></span><br><span class="line">    context.<span class="string">&#x27;component-scan&#x27;</span>(<span class="string">&#x27;base-package&#x27;</span>: <span class="string">&quot;com.smart&quot;</span>)</span><br><span class="line">    mvc.<span class="string">&#x27;annotation-driven&#x27;</span>(<span class="string">&#x27;validator&#x27;</span>: <span class="string">&quot;validator&quot;</span>)</span><br><span class="line"></span><br><span class="line">    validator(LocalValidatorFactoryBean) &#123;</span><br><span class="line">        providerClass = HibernateValidator.<span class="keyword">class</span></span><br><span class="line">        <span class="title class_">validationMessageSource</span> = ref(<span class="string">&quot;messageSource&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    messageSource(ReloadableResourceBundleMessageSource) &#123;</span><br><span class="line">        basenames = [<span class="string">&quot;classpath:messages&quot;</span>, <span class="string">&quot;classpath:org/hibernate/validator/ValidationMessages&quot;</span>]</span><br><span class="line">        defaultEncoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">        cacheSeconds = <span class="number">60</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    viewResolver(InternalResourceViewResolver) &#123;</span><br><span class="line">        prefix = <span class="string">&quot;/WEB-INF/jsp/&quot;</span></span><br><span class="line">        suffix = <span class="string">&quot;.jsp&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mvc.interceptors() &#123;</span><br><span class="line">        localeChangeInterceptor(LocaleChangeInterceptor) &#123;</span><br><span class="line">            paramName = <span class="string">&quot;language&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cookieLocaleResolver(CookieLocaleResolver) &#123;</span><br><span class="line">        cookieName = <span class="string">&quot;language&quot;</span></span><br><span class="line">        cookieMaxAge = <span class="string">&quot;3600&quot;</span></span><br><span class="line">        defaultLocale = <span class="string">&quot;zh_CN&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="父子容器"><a href="#父子容器" class="headerlink" title="父子容器"></a>父子容器</h3><p>通过 HierarchicalBeanFactory 接口，Spring 的IoC 容器可以建⽴⽗⼦层级关联的容器体系，⼦容器可以访问⽗容器中的 Bean，但⽗容器不能访问⼦容器中的Bean。在容器内，Bean 的id必须是唯⼀的，但⼦容器可以拥有⼀个和⽗容器id 相同的Bean。⽗⼦容器层级体系增强了 Spring 容器架构的扩展性和灵活性，因为第三⽅可以通过编程的⽅式为⼀个已经存在的容器添加⼀个或多个特殊⽤途的⼦容器，以提供⼀些额外的功能。</p>
<p>Spring 使⽤⽗⼦容器实现了很多功能，⽐如在 Spring MVC 中，展现层 Bean位于⼀个⼦容器中，⽽业务层和持久层 Bean 位于⽗容器中。这样，展现层 Bean就可以引⽤业务层和持久层 Bean，⽽业务层和持久层 Bean 则看不到展现层 Bean。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>我们知道 Web 容器中的 Servlet 拥有明确的⽣命周期，Spring 容器中的Bean也拥有相似的⽣命周期。Bean ⽣命周期由多个特定的⽣命阶段组成，每个⽣命阶段都开出了⼀扇门，允许外界借由此门对 Bean 施加控制。在 Spring 中，可以从两个层⾯定义 Bean 的⽣命周期：</p>
<ul>
<li>第⼀个层⾯是 Bean 的作⽤范围；</li>
<li>第⼆个层⾯是实例化 Bean 时所经历的⼀系列阶段。</li>
</ul>
<p>下⾯分别对 BeanFactory 和<br>ApplicationContext 中Bean的⽣命周期进⾏分析。</p>
<h3 id="BeanFactory中Bean的生命周期"><a href="#BeanFactory中Bean的生命周期" class="headerlink" title="BeanFactory中Bean的生命周期"></a>BeanFactory中Bean的生命周期</h3><h4 id="生命周期图解"><a href="#生命周期图解" class="headerlink" title="生命周期图解"></a>生命周期图解</h4><pre class="mermaid">

stateDiagram
[*] --&gt; ⭐️调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法:[通过getBean()方法获取一个Bean]

⭐️调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法 --&gt; 实例化

实例化 --&gt; ⭐️调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()方法

⭐️调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()方法 --&gt; ⭐️调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法

⭐️调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法 --&gt; 设置属性值

设置属性值 --&gt; 调用BeanNameAware的setBeanName()方法

调用BeanNameAware的setBeanName()方法 --&gt; 调用BeanNameAware的setBeanFactory()方法

调用BeanNameAware的setBeanFactory()方法 --&gt;⭐️调用BeanPostProcessor的postProcessBeforeInitialization()方法

⭐️调用BeanPostProcessor的postProcessBeforeInitialization()方法 --&gt; 调用InitializingBean的afterPropertiesSet()方法

调用InitializingBean的afterPropertiesSet()方法 --&gt; 通过init_method属性配置的初始化方法

通过init_method属性配置的初始化方法--&gt; ⭐️调用BeanPostProcessor的postProcessAfterInitialization()方法

⭐️调用BeanPostProcessor的postProcessAfterInitialization()方法 --&gt; Spring缓冲池中准备就绪的Bean:[singleton]

⭐️调用BeanPostProcessor的postProcessAfterInitialization()方法 --&gt; 将准备就绪的Bean交给调用者:[prototype]

Spring缓冲池中准备就绪的Bean --&gt; 调用DisposableBean的destroy()方法:[容器销毁]

调用DisposableBean的destroy()方法--&gt;通过destroy_method属性配置的销毁方法

通过destroy_method属性配置的销毁方法 --&gt; [*]
</pre>

<p>具体过程如下：</p>
<ol>
<li>当调⽤者通过 getBean（beanName）向容器请求某⼀个 Bean 时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor 接口，则在实例化 Bean之前，将调⽤接口的 postProcessBeforeInstantiation()⽅法。</li>
<li>根据配置情况调⽤ Bean 构造函数或⼯⼚⽅法实例化 Bean。</li>
<li>如果容器注册了 InstantiationAwareBeanPostProcessor 接口，那么在实例化 Bean<br>之后，调⽤该接口的 postProcessAfterInstantiation（）⽅法，可在这⾥对已经实例化的对象<br>进⾏⼀些“梳妆打扮”。</li>
<li>如果 Bean 配置了属性信息，那么容器在这⼀步着⼿将配置值设置到Bean 对应的属性中，不过在设置每个属性之前将先调⽤ InstantiationAwareBeanPostProcessor 接口的 postProcessPropertyValues（）⽅法。</li>
<li>调⽤ Bean的属性设置⽅法设置属性值。</li>
<li>如果 Bean 实现了 org.springframework.beans.factory. BeanNameAware 接口，则将调⽤ setBeanName（）接口⽅法，将配置⽂件中该Bean 对应的名称设置到 Bean中。</li>
<li>如果 Bean 实现了 org.springframework.beans.factory.BeanFactoryAware 接⼝，则将调⽤ setBeanFactory0接⼝⽅法，将 BeanFactory 容器实例设置到Bean中。</li>
<li>如果 BeanFactory 装配了 org.springframework.beans.factory.config.BeanPostProcessor后处理器，则将调⽤ BeanPostProcessor 的 Object postProcessBeforeInitialization（Objectbean, String beanName）接⼝⽅法对 Bean 进⾏加⼯操作。其中，⼊参bean 是当前正在处理的Bean，⽽beanName 是当前 Bean 的配置名，返回的对象为加⼯处理后的Bean。⽤户可以使⽤该⽅法对某些 Bean 进⾏特殊的处理，甚⾄改变 Bean 的⾏为。BeanPostProcessor在 Spring 框架中占有重要的地位，为容器提供对 Bean 进⾏后续加⼯处理的切⼊点，Spring 容器所提供的各种“神奇功能”（如 AOP、动态代理等）都通过 BeanPostProcessor实施。</li>
<li>如果 Bean 实现了 InitializingBean 接口，则将调⽤接口的 afterPropertiesSet0⽅法。</li>
<li>如果在<code>&lt;bean&gt;</code>中通过 init-method 属性定义了初始化⽅法，则将执⾏这个⽅法。</li>
<li>BeanPostProcessor 后处理器定义了两个⽅法：其⼀是 postProcessBefore<br>Initialization（），在第（8）步调⽤；其⼆是 Object postProcessAfterlnitialization（Object bean，String beanName），这个⽅法在此时调⽤，容器再次获得对 Bean 进⾏加⼯处理的机会。</li>
<li>如果在<code>&lt;bean&gt;</code>中指定 Bean 的作⽤范围为 scope&#x3D;”prototype”，则将 Bean 返回<br>给调⽤者，调⽤者负责 Bean 后续⽣命的管理，Spring 不再管理这个 Bean的⽣命周期。如果将作⽤范围设置为 scope&#x3D;”singleton”，则将 Bean 放⼊ Spring IoC 容器的缓存池中，<br>并将 Bean 引⽤返回给调⽤者，Spring 继续对这些 Bean 进⾏后续的⽣命管理.</li>
<li>对于 scope&#x3D;”singleton”的Bean（默认情况），当容器关闭时，将触发 Spring 对<br>Bean 后续⽣命周期的管理⼯作。如果 Bean 实现了 DisposableBean接口，则将调⽤接口<br>的 destory（）⽅法，可以在此编写释放资源、记录⽇志等操作。</li>
<li>对于 scope&#x3D;”singleton”的Bean，如果通过<code>&lt;bean&gt;</code>的 destroy-method 属性指定了<br>Bean 的销毁⽅法，那么 Spring 将执⾏ Bean 的这个⽅法，完成 Bean 资源的释放等操作。</li>
</ol>
<p>Bean 的完整⽣命周期从 Spring 容器着⼿实例化 Bean 开始，直到最终销毁 Bean。其中经过了许多关键点，每个关键点都涉及特定的⽅法调⽤，可以将这些⽅法⼤致划分 为4类。</p>
<ul>
<li>Bean ⾃⾝的⽅法：如调⽤ Bean构造函数实例化 Bean、调⽤ Setter设置 Bean 的 属性值及通过<code>&lt;bean&gt;</code>的 init-method 和 destroy-method 所指定的⽅法。</li>
<li>Bean级⽣命周期接口⽅法：如 BeanNameAware、BeanFactoryAware、 InitializingBean<br>和 DisposableBean，这些接口⽅法由 Bean 类直接实现。</li>
<li>容器级⽣命周期接口⽅法：在图4中带“⭐️”的步骤是由InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现的，⼀般称它们的实现类为“后处理器”。后处理器接口⼀般不由 Bean 本⾝实现，它们独⽴于 Bean，实现<br>类以容器附加装置的形式注册到 Spring 容器中，并通过接口反射为 Spring 容器扫描识别。当Spring 容器创建任何 Bean 的时候，这些后处理器都会发⽣作⽤，所以这些后处理器的影响是全局性的。当然，⽤户可以通过合理地编写后处理器，让其仅对感兴趣的 Bean 进⾏加⼯处理。</li>
<li>⼯⼚后处理器接⼝⽅法：包括 AspectJWeavingEnabler、CustomAutowireConfigurer、<br>ConfigurationClassPostProcessor 等⽅法。⼯⼚后处理器也是容器级的，在应⽤上下⽂装配配置⽂件后⽴即调⽤。</li>
</ul>
<p>Bean 级⽣命周期接⼝和容器级⽣命周期接⼝是个性和共性辩证统⼀思想的体现，前者解决 Bean 个性化处理的问题，⽽后者解决容器中某些 Bean 共性化处理的问题。</p>
<p>Spring 容器中是否可以注册多个后处理器呢？答案是肯定的。只要它们同时实现org.springframework.core.Ordered 接口，容器将按特定的顺序依次调⽤这些后处理器。所以图中带“⭐️”的步骤都可能调⽤多个后处理器进⾏⼀系列加⼯操作。</p>
<p>InstantiationAwareBeanPostProcessor 其实是 BeanPostProcessor 接口的⼦接口，Spring为其提供了⼀个适配器类 InstantiationAwareBeanPostProcessorAdapter，⼀般情况下，可以⽅便地扩展该适配器覆盖感兴趣的⽅法以定义实现类。下⾯将通过⼀个具体的实例来更好<br>地理解 Bean ⽣命周期的各个步骤。</p>
<h4 id="窥探-Bean-⽣命周期的实例"><a href="#窥探-Bean-⽣命周期的实例" class="headerlink" title="窥探 Bean ⽣命周期的实例"></a>窥探 Bean ⽣命周期的实例</h4><p>依旧采⽤前⾯介绍的Car 类，让它实现所有 Bean级的⽣命周期接口。此外，还定义了初始化和销毁的⽅法，这两个⽅法将通过<code>&lt;bean＞</code>的 init-method 和 destroy-method 属性指定，如代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//①管理Bean⽣命周期的接⼝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, BeanNameAware, InitializingBean, DisposableBean &#123;</span><br><span class="line"> <span class="keyword">private</span> String brand;</span><br><span class="line"> <span class="keyword">private</span> String color;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> maxSpeed;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"> <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用Car()构造函数。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> brand;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用setBrand()设置属性。&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;brand:&quot;</span> + brand + <span class="string">&quot;/color:&quot;</span> + color + <span class="string">&quot;/maxSpeed:&quot;</span>+ maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaxSpeed</span><span class="params">(<span class="type">int</span> maxSpeed)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.maxSpeed = maxSpeed;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;introduce:&quot;</span>+<span class="built_in">this</span>.toString());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//②BeanFactoryAware接⼝⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用BeanFactoryAware.setBeanFactory()。&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//③BeanNameAware接⼝⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用BeanNameAware.setBeanName()。&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.beanName = beanName;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//④InitializingBean接⼝⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用InitializingBean.afterPropertiesSet()。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⑤DisposableBean接⼝⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用DisposableBean.destory()。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//⑥通过&lt;bean&gt;的init-method属性指定的初始化⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myInit</span><span class="params">()</span> &#123;  </span><br><span class="line">  System.out.println(<span class="string">&quot;调用myInit()，将maxSpeed设置为240。&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.maxSpeed = <span class="number">240</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//⑦通过 bean&gt;的destroy-method属性指定的销毁⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myDestory</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用myDestroy()。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Car 类在②③④⑤处实现了 BeanFactoryAware、BeanNameAware、InitializingBean、DisposableBean 这些 Bean 级的⽣命周期控制接口；在⑥和⑦处定义了 myInit（）和myDestroy0）⽅法，以便在配置⽂件中通过 init-method 和 destroy-method 属性定义初始化和销毁⽅法。</p>
<p>MyInstantiationAwareBeanPostProcessor 通过扩展 InstantiationAwareBeanPostProcessor适配器 InstantiationAwareBeanPostProcessorAdapter 提供实现，如代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.beanfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">InstantiationAwareBeanPostProcessorAdapter</span>&#123;</span><br><span class="line"><span class="comment">//①接⼝⽅法：在实例化Bean前调⽤</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">//①-1仅对容器中的car Bean处理</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;car&quot;</span>.equals(beanName))&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;MyInstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation&quot;</span>);   </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//②接⼝⽅法：在实例化Bean后调⽤</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="comment">//②-1仅对容器中的car Bean进⾏处理</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;car&quot;</span>.equals(beanName))&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//③接⼝⽅法：在设置某个属性时调⽤</span></span><br><span class="line"> <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(</span></span><br><span class="line"><span class="params">   PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span><br><span class="line">   <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//③-1仅对容器中的car Bean进⾏处理，还可以通过pdst⼊参进⾏过滤，</span></span><br><span class="line">    <span class="comment">//只对car的某个特定属性进⾏处理</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;car&quot;</span>.equals(beanName))&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;InstantiationAwareBeanPostProcessor.postProcessPropertyValues&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pvs;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 MyInstantiationAwareBeanPostProcessor 中，通过过滤条件仅对 car Bean 进⾏处理，对其他的Bean⼀概视⽽不⻅。</p>
<p>此外，还提供了⼀个 BeanPostProcessor 实现类，在该实现类中仅对 car Bean 进⾏处理，对配置⽂件所提供的属性设置值进⾏判断，并执⾏相应的“补缺补漏”操作，如代码清所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.beanfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">  <span class="keyword">if</span>(beanName.equals(<span class="string">&quot;car&quot;</span>))&#123;</span><br><span class="line">   <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)bean;</span><br><span class="line">   <span class="keyword">if</span>(car.getMaxSpeed() &gt;= <span class="number">200</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;调用MyBeanPostProcessor.postProcessAfterInitialization()，将maxSpeed调整为200。&quot;</span>);</span><br><span class="line">    car.setMaxSpeed(<span class="number">200</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">  <span class="keyword">if</span>(beanName.equals(<span class="string">&quot;car&quot;</span>))&#123;</span><br><span class="line">   <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)bean;</span><br><span class="line">   <span class="keyword">if</span>(car.getColor() == <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;调用MyBeanPostProcessor.postProcessBeforeInitialization()，color为空，设置为默认黑色。&quot;</span>);</span><br><span class="line">    car.setColor(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 MyBeanPostProcessor 类的 postProcessBeforeInitialization()⽅法中，⾸先判断所处理的Bean是否名为car，如果是，则进⼀步判断该 Bean 的color 属性是否为空；如果空，则将该属性设置⼒“⿊⾊”。在 postProcessAfterInitialization()⽅法中，仅对名为car的Bean进⾏处理，判断其 maxSpeed 是否超过最⼤速度200，如果超过，则将其设置为200。<br>⾄于如何将 MyInstantiationAwareBeanPostProcessor 和 MyBeanPostProcessor 这两个后处理器注册到 BeanFactory 容器中，请参看代码:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.Car&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">init-method</span>=<span class="string">&quot;myInit&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;myDestroy&quot;</span> <span class="attr">p:brand</span>=<span class="string">&quot;红旗CA72&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">p:maxspeed</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 init-method 指定 Car 的初始化⽅法为 myInitO；通过 destroy-method 指定Car<br>的销毁⽅法为 myDestroy（）；同时通过 scope 定义了Car 的作⽤范围（关于 Bean 作⽤范<br>围的详细讨论，请参⻅5.8节）。</p>
<p>下⾯让容器装载配置⽂件，然后分别注册上⾯所提供的两个后处理器，如代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.beanfactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.smart.Car;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">LifeCycleInBeanFactory</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//①下面两句装载配置文件并启动容器</span></span><br><span class="line">     <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/smart/beanfactory/beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">       BeanFactory bf= <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">       <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>((DefaultListableBeanFactory)bf);</span><br><span class="line">       reader.loadBeanDefinitions(res);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//②向容器中注册MyBeanPostProcessor后处理器</span></span><br><span class="line">       ((ConfigurableBeanFactory)bf).addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">MyBeanPostProcessor</span>());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//③向容器中注册MyInstantiationAwareBeanPostProcessor后处理器</span></span><br><span class="line">       ((ConfigurableBeanFactory)bf).addBeanPostProcessor(</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">MyInstantiationAwareBeanPostProcessor</span>());</span><br><span class="line">       <span class="comment">//④第一次从容器中获取car，将触发容器实例化该Bean，这将引发Bean生命周期方法的调用。</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> (Car)bf.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">       car1.introduce();</span><br><span class="line">       car1.setColor(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//⑤第二次从容器中获取car，直接从缓存池中获取</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> (Car)bf.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//⑥查看car1和car2是否指向同一引用</span></span><br><span class="line">       System.out.println(<span class="string">&quot;car1==car2:&quot;</span>+(car1==car2));</span><br><span class="line">       <span class="comment">//⑦关闭容器</span></span><br><span class="line">       ((DefaultListableBeanFactory)bf).destroySingletons();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  LifeCycleInBeanFactory();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在①处，装载了配置⽂件并启动容器。在②处，向容器中注册了 MyBeanPostProcessor<br>后处理器，注意对 BeanFactory 类型的bf变量进⾏了强制类型转换，因为⽤于注册后处<br>理器的 addBeanPostProcessor（）⽅法是在 ConfigurableBeanFactory 接口中定义的。如果有多个后处理器，则可以按照相似的⽅式调⽤ addBeanPostProcessor（）⽅法进⾏注册。需要<br>强调的是，后处理器的实际调⽤顺序和注册顺序是⽆关的，在具有多个后处理器的情况下，必须通过实现的 org.springframework.core.Ordered 接口来确定调⽤顺序。</p>
<p>在③处，按照注册 MyBeanPostProcessor 后处理器相同的⽅法注册 MyInstantiationAwareBeanPostProcessor 后处理器，Spring 容器会⾃动检查后处理器是否实现了InstantiationAwareBeanPostProcessor 接口，并据此判断后处理器的类型。</p>
<p>在④处，第⼀次从容器中获取 car Bean，容器将按上面图中描述的 Bean⽣命周期过程，实例化 Car 并将其放⼊缓存池中，然后再将这个 Bean 引⽤返回给调⽤者。在⑤处，再次从容器中获取 car Bean，Bean 将从容器缓存池中直接取出，不会引发⽣命周期相关⽅法的执⾏。如果 Bean 的作⽤范围定义为 scope&#x3D;”prototype”，则第⼆次 getBean（）时，⽣命周期⽅法会再次被调⽤，因为 prototype 范围的 Bean 每次都返回新的实例。在⑥处，检验 carl 和 car2是否指向相同的对象。<br>运⾏ BeanLifeCycle，在控制台上得到以下输出信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyInstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</span><br><span class="line">调用Car()构造函数。</span><br><span class="line">InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</span><br><span class="line">InstantiationAwareBeanPostProcessor.postProcessPropertyValues</span><br><span class="line">调用setBrand()设置属性。</span><br><span class="line">调用BeanNameAware.setBeanName()。</span><br><span class="line">调用BeanFactoryAware.setBeanFactory()。</span><br><span class="line">调用MyBeanPostProcessor.postProcessBeforeInitialization()，color为空，设置为默认黑色。</span><br><span class="line">调用InitializingBean.afterPropertiesSet()。</span><br><span class="line">调用myInit()，将maxSpeed设置为240。</span><br><span class="line">调用MyBeanPostProcessor.postProcessAfterInitialization()，将maxSpeed调整为200。</span><br><span class="line">introduce:brand:红旗CA72/color:黑色/maxSpeed:200</span><br><span class="line">car1==car2:true</span><br><span class="line">调用DisposableBean.destory()。</span><br><span class="line">调用myDestroy()。</span><br></pre></td></tr></table></figure>

<p>仔细观察输出的信息，发现其验证了前⾯所介绍的 Bean ⽣命周期的完整过程。在⑦处，通过 destroySingletons⽅法关闭了容器，由于Car 实现了销毁接口并指定了销毁⽅法，所以容器将触发调⽤这两个⽅法。</p>
<h4 id="关于-Bean-⽣命周期接⼝的探讨"><a href="#关于-Bean-⽣命周期接⼝的探讨" class="headerlink" title="关于 Bean ⽣命周期接⼝的探讨"></a>关于 Bean ⽣命周期接⼝的探讨</h4><p>通过实现 Spring 的Bean ⽣命周期接口对Bean 进⾏额外控制，虽然让 Bean 具有了<br>更细致的⽣命周期阶段，但也带来了⼀个问题：Bean 和 Spring 框架紧密地绑定在⼀起，<br>这和 Spring⼀直推崇的“不对应⽤程序类作任何限制” 的理念是相悖的。因此，如果⽤<br>户希望将业务类完全POJO化，则可以只实现⾃⼰的业务接口，不需要和某个特定框架（包括 Spring 框架）的接口关联。可以通过<code>&lt;bean&gt;</code>的 init-method 和 destroy-method 属性<br>配置⽅式为Bean 指定初始化和销毁的⽅法，采⽤这种⽅式对Bean ⽣命周期的控制效果和通过实现 InitializingBean 和 DisposableBean接口所达到的效果是完全相同的。采⽤前者的配置⽅式可以使 Bean 不需要和特定的 Spring 框架接口绑定，达到了框架解耦的⽬的。此外，Spring 还拥有⼀个 Bean 后置处理器 InitDestroyAnnotationBeanPostProcessor，它负责对标注了@PostConstruct、@PreDestroy 的Bean 进⾏处理，在Bean 初始化后及销毁前执⾏相应的逻辑。喜欢注解的读者，可以通过 InitDestroyAnnotationBeanPost Processor达到和以上两种⽅式相同的效果（如果在 ApplicationContext 中，则已经默认装配了该处理器）。</p>
<p>对于 BeanFactoryAware 和 BeanNameAware接⼝，前者让Bean感知容器（BeanFactory实例），⽽后者让Bean获得配置⽂件中对应的配置名称。⼀般情况下，⽤户⼏乎不需要关⼼这两个接⼝。如果 Bean 希望获取容器中的其他 Bean，则可以通过属性注⼊的⽅式引⽤这些 Bean；如果 Bean 希望在运⾏期获知在配置⽂件中的 Bean名称，则可以简单地将名称作为属性注⼊。</p>
<p>综上所述，我们认为，除⾮编写⼀个基于 Spring 之上的扩展插件或⼦项⽬之类的东⻄，否则⽤户完全可以抛开以上4个 Bean ⽣命周期的接⼝类，使⽤更好的⽅案替代之。</p>
<p>但 BeanPostProcessor 接⼝却不⼀样，它不要求 Bean 去继承它，可以完全像插件⼀样注册到 Spring 容器中，为容器提供额外的功能。Spring 容器充分利⽤了 BeanPostProcessor对 Bean 进⾏加⼯处理，当我们讲到 Spring 的 AOP 功能时，还会对此进⾏分析，了解<br>BeanPostProcessor 对Bean 的影响，对于深⼊理解Spring核⼼功能的⼯作机理将会有很⼤的<br>帮助。很多 Spring扩展插件或Spring ⼦项⽬都是使⽤这些后处理器完成激动⼈⼼的功能的。</p>
<h3 id="AplicationContext-中-Bean-的⽣命周期"><a href="#AplicationContext-中-Bean-的⽣命周期" class="headerlink" title="AplicationContext 中 Bean 的⽣命周期"></a>AplicationContext 中 Bean 的⽣命周期</h3><p>Bean 在应⽤上下⽂中的⽣命周期和在 BeanFactory 中的⽣命周期类似，不同的是，如果 Bean 实现了 org.springframework.context.ApplicationContextAware 接口，则会增加⼀个调⽤该接口⽅法 setApplicationContext0的步骤，如下图所示。</p>
<p>此外，如果在配置⽂件中声明了⼯⼚后处理器接口 BeanFactoryPostProcessor 的实现类，则应⽤上下⽂在装载配置⽂件之后、初始化 Bean 实例之前将调⽤这些<br>BeanFactoryPostProcessor 对配置信息进⾏加⼯处理。Spring 框架提供了多个⼯⼚后处理器，如 CustomEditorConfigurer、PopertyPlaceholderConfigurer 等，我们将在第5章中详<br>细介绍它们的功⽤。如果在配置⽂件中定义了多个⼯⼚后处理器，那么最好让它们实现org.springframework.core.Ordered 接口，以便 Spring 以确定的顺序调⽤它们。⼯⼚后处理器是容器级的，仅在应⽤上下⽂初始化时调⽤⼀次，其⽬的是完成⼀些配置⽂件的加⼯处理⼯作。</p>
<p>ApplicationContext 和 BeanFactory另⼀个最⼤的不同之处在于：前者会利⽤ Java 反射机制⾃动识别出配置⽂件中定义的 BeanPostProcessor、InstantiationAwareBeanPost<br>Processor 和 BeanFactoryPostProcessor，并⾃动将它们注册到应⽤上下⽂中；⽽后者需要在代码中通过⼿⼯调⽤ addBeanPostProcessor（）⽅法进⾏注册。这也是为什么在应⽤开发时普遍使⽤ ApplicationContext ⽽很少使⽤BeanFactory 的原因之⼀。</p>
<p>在 ApplicationContext 中，只需在配置⽂件中通过<code>&lt;bean&gt;</code>定义⼯⼚后处理器和Bean后处理器，它们就会按预期的⽅式运⾏。<br><img src="/images/spring/Spring4.x_%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/Application%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Application中Bean的生命周期"></p>
<p>来看⼀个使⽤⼯⼚后处理器的实例。假设我们希望对配置⽂件中 car 的brand 配置属性进⾏调整，则可以编写⼀个如代码所⽰的⼯⼚后处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span>&#123;</span><br><span class="line"><span class="comment">//①对car &lt;bean&gt;的brand属性配置信息进⾏“偷梁换柱”的加⼯操作</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory bf)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> bf.getBeanDefinition(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">  bd.getPropertyValues().addPropertyValue(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;奇瑞QQ&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;调用MyBeanFactoryPostProcessor.postProcessBeanFactory()！&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext 在启动时，将⾸先为配置⽂件中的每个<code>&lt;bean&gt;</code>⽣成⼀个BeanDefinition 对象，BeanDefinition 是<code>&lt;bean&gt;</code>在 Spring 容器中的内部表⽰。当配置⽂件中所有的<code>&lt;bean&gt;</code>都被解析成 BeanDefinition 时，ApplicationContext 将调⽤⼯⼚后处理器的⽅法，因此，我们有机会通过程序的⽅式调整 Bean 的配置信息。在这⾥，我们将 car 对应的BeanDefinition 进⾏调整，将 brand 属性设置为“奇瑞QQ”，具体配置如代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--①这个brand属性的值将被⼯⼚后处理器更改掉 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.Car&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">p:brand</span>=<span class="string">&quot;红旗CA72&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">p:maxSpeed</span>=<span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--②⼯⼚后处理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.context.MyBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--③注册Bean后处理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanFactoryPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.context.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在②和③处定义的 BeanPostProcessor 和 BeanFactoryPostProcessor 会⾃动被<br>ApplicationContext 识别并注册到容器中。在②处注册的⼯⼚后处理器将会对在①处配置的属性值进⾏调整。在③处还声明了⼀个 Bean 后处理器，它也可以对 Bean 的属性进⾏调整。启动容器并查看 car Bean 的信息，将发现 car Bean 的brand 属性成功被⼯⼚后处理器更改了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本章中，我们深⼊分析了IoC 的概念。控制反转的概念其实包含两个层⾯的意思：</p>
<ol>
<li>“控制”是接口实现类的选择控制权；</li>
<li>⽽“反转”是指这种选择控制权从调⽤类转移到外部第三⽅类或容器的⼿中。</li>
</ol>
<p>为了揭开 Spring 依赖注⼊的神秘⾯纱，透视 Spring 的机理，我们对Java 语⾔的反射技术进⾏了快速学习。掌握了这些知识，读者不但可以深刻理解 Spring 的内部实现机制，还可以⾃⼰动⼿编写⼀个IoC 容器。BeanFactory、ApplicationContext 和 WebApplicationContext 是 Spring 框架的3个核⼼接口，框架中其他⼤部分的类都围绕它们展开，为它们提供⽀持和服务。在这些⽀持类中，Resource 是⼀个不可忽视的重要接口，框架通过 Resource 实现了和具体资源的解<br>耦，不论它们位于何种存储介质中，都可以通过相同的实例返回。与 Resource 配合的另⼀个接口是 ResourceLoader,ResourceLoader 采⽤了策略模式，可以通过传⼊资源地址的信息，⾃动选择适合的底层资源实现类，上层对资源的引⽤提供了极⼤的便利。Spring 为Bean 提供了细致周全的⽣命周期过程，通过实现特定的接口或通过<code>&lt;bean&gt;</code>属性设置，都可以对 Bean 的⽣命周期过程施加影响。Bean 的⽣命周期不但和其实现的接口相关，还与 Bean 的作⽤范围有关。为了让 Bean 绑定在 Spring 框架上，我们推荐使⽤配置⽅式⽽⾮接口⽅式进⾏Bean ⽣命周期的控制。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/%E7%B2%BE%E9%80%9ASpring4-x%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/" rel="tag"># 精通Spring4.x企业应用开发实战</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/13/Java%E7%A8%8B%E5%BA%8F%E5%91%98-%E5%88%AB%E7%94%A8Statck/" rel="prev" title="Java程序员,别用Statck">
                  <i class="fa fa-angle-left"></i> Java程序员,别用Statck
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/14/UML%E7%B1%BB%E5%9B%BE/" rel="next" title="UML类图">
                  UML类图 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">星之辰</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">68k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:08</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
